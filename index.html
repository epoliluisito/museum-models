<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"/>
<title>fear</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script>
  // --- Cinematic haze + visible beams (no external deps) ----------------------
  (function () {
    // Shared smoke texture (CanvasTexture)
    let _smokeTex = null;
    function getSmokeTexture () {
      if (_smokeTex) return _smokeTex;

      const size = 512;
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      // Base: layered soft blobs
      ctx.clearRect(0, 0, size, size);
      ctx.globalCompositeOperation = 'source-over';
      for (let i = 0; i < 140; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const r = 40 + Math.random() * 170;

        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0.0, 'rgba(255,255,255,' + (0.10 + Math.random() * 0.18) + ')');
        g.addColorStop(0.55, 'rgba(255,255,255,' + (0.04 + Math.random() * 0.08) + ')');
        g.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.fillRect(x - r, y - r, r * 2, r * 2);
      }

      // Blur pass for softness (offscreen)
      const o = document.createElement('canvas');
      o.width = o.height = size;
      const octx = o.getContext('2d');
      octx.filter = 'blur(12px)';
      octx.drawImage(c, 0, 0);

      ctx.clearRect(0, 0, size, size);
      ctx.globalAlpha = 0.95;
      ctx.drawImage(o, 0, 0);

      // Mild contrast to avoid "milky" look
      ctx.globalCompositeOperation = 'source-in';
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(0, 0, size, size);
      ctx.globalCompositeOperation = 'source-over';

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(2, 2);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      _smokeTex = tex;
      return _smokeTex;
    }

    // Fake volumetric light cone using a drifting smoke texture.
    // Implemented as a transparent cone mesh (cheap, stable, cinematic).
    // Fake volumetric light cone using drifting smoke texture,
// but with a soft edge and soft floor contact (multi-layer + contact bloom).
// Implemented as a small stack of transparent cones (cheap, stable, cinematic).
AFRAME.registerComponent('light-beam', {
  schema: {
    length: { type: 'number', default: 6.0 },
    radius: { type: 'number', default: 1.2 },
    opacity:{ type: 'number', default: 0.10 },
    color:  { type: 'color', default: '#ffffff' },
    driftU: { type: 'number', default: 0.02 },
    driftV: { type: 'number', default: 0.06 },

    // softness controls (no perf cliff)
    layers: { type: 'int', default: 3 },             // 1..4 (use 1 for a single cone)
    edgeSoftness: { type: 'number', default: 0.18 }, // 0..0.35 (outer radius boost)
    floorSoftness:{ type: 'number', default: 1.35 }, // contact disc radius multiplier
    floorOpacity: { type: 'number', default: 0.22 }  // contact disc opacity (relative to opacity)
  },

  init: function () {
    // Shared textures
    const baseSmoke = getSmokeTexture();
    this._layers = [];
    this._group = new THREE.Group();
    this.el.setObject3D('beam', this._group);

    // Contact bloom texture (radial falloff; generated once per component)
    const makeContactTex = () => {
      const s = 256;
      const c = document.createElement('canvas');
      c.width = c.height = s;
      const ctx = c.getContext('2d');

      ctx.clearRect(0, 0, s, s);
      const g = ctx.createRadialGradient(s/2, s/2, 0, s/2, s/2, s/2);
      g.addColorStop(0.00, 'rgba(255,255,255,0.55)');
      g.addColorStop(0.20, 'rgba(255,255,255,0.22)');
      g.addColorStop(0.55, 'rgba(255,255,255,0.07)');
      g.addColorStop(1.00, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, s, s);

      // Tiny noise/dither to break perfect circle edge
      const img = ctx.getImageData(0, 0, s, s);
      for (let i = 0; i < img.data.length; i += 4) {
        const n = (Math.random() - 0.5) * 10; // subtle
        img.data[i]   = Math.min(255, Math.max(0, img.data[i]   + n));
        img.data[i+1] = Math.min(255, Math.max(0, img.data[i+1] + n));
        img.data[i+2] = Math.min(255, Math.max(0, img.data[i+2] + n));
      }
      ctx.putImageData(img, 0, 0);

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      return tex;
    };

    this._contactTex = makeContactTex();

    // Geometry: cone points along +Y; translated so the TIP sits at origin and cone extends toward -Y.
    // This matches aim-down-axis which aligns local -Y to the target direction.
    const coneGeo = new THREE.ConeGeometry(1, 1, 56, 1, true);
    coneGeo.translate(0, -0.5, 0);

    // Layer recipe: inner is strongest, outer is widest/softest.
    const clampLayers = (n) => Math.max(1, Math.min(4, n|0));
    const L = clampLayers(this.data.layers);

    const opMults = (L === 1) ? [1.0]
                 : (L === 2) ? [1.0, 0.42]
                 : (L === 3) ? [1.0, 0.60, 0.34]
                 :            [1.0, 0.70, 0.48, 0.30];

    const radiusMult = (i) => {
      const s = this.data.edgeSoftness;
      const t = (i / Math.max(1, (L - 1)));
      return 1.0 + s * t;
    };

    const lenMult = (i) => {
      const t = (i / Math.max(1, (L - 1)));
      return 1.0 - 0.04 * t;
    };

    for (let i = 0; i < L; i++) {
      const tex = baseSmoke.clone();
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1.15 + i * 0.12, 6.0);
      tex.offset.set(Math.random(), Math.random());
      tex.needsUpdate = true;

      const mat = new THREE.MeshBasicMaterial({
        map: tex,
        color: new THREE.Color(this.data.color),
        transparent: true,
        opacity: this.data.opacity * opMults[i],
        depthWrite: false,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });

      const mesh = new THREE.Mesh(coneGeo, mat);
      mesh.renderOrder = 999; // keep on top of foggy background
      this._group.add(mesh);

      this._layers.push({
        mesh,
        tex,
        opMult: opMults[i],
        radMult: radiusMult(i),
        lenMult: lenMult(i),
        driftMul: 0.85 + i * 0.18
      });
    }

    // Soft contact bloom disc at the beam end (breaks the “perfect circle on floor”)
    const discGeo = new THREE.CircleGeometry(1, 40);
    discGeo.rotateX(-Math.PI / 2); // face +Y

    const discMat = new THREE.MeshBasicMaterial({
      map: this._contactTex,
      color: new THREE.Color(this.data.color),
      transparent: true,
      opacity: this.data.opacity * this.data.floorOpacity,
      depthWrite: false,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending
    });

    this._disc = new THREE.Mesh(discGeo, discMat);
    this._disc.renderOrder = 998;
    this._group.add(this._disc);

    // Internal time for subtle organic edge drift (no heavy noise)
    this._tt = 0;
    this._baseLen = this.data.length;
    this._baseRad = this.data.radius;

    this._applyScale();
  },

  _applyScale: function () {
    if (!this._layers || !this._layers.length) return;

    const len = Math.max(0.01, this.data.length);
    const rad = Math.max(0.001, this.data.radius);

    this._baseLen = len;
    this._baseRad = rad;

    for (let i = 0; i < this._layers.length; i++) {
      const L = this._layers[i];
      L.mesh.scale.set(rad * L.radMult, len * L.lenMult, rad * L.radMult);
      if (L.tex) {
        // Keep wisps stretched along beam length.
        L.tex.repeat.set(1.15 + i * 0.12, Math.max(2.0, len * 1.12));
        L.tex.needsUpdate = true;
      }
    }

    if (this._disc) {
      const discRad = rad * this.data.floorSoftness;
      this._disc.scale.set(discRad, 1, discRad);
      // place disc at the beam end (local space), slightly above the surface to avoid z-fighting.
      this._disc.position.set(0, -len + 0.02, 0);
    }
  },

  update: function () {
    if (!this._layers) return;

    // If user changes layers count, rebuild cleanly (rare).
    const desired = Math.max(1, Math.min(4, this.data.layers|0));
    if (this._layers.length !== desired) {
      this.remove();
      this.init();
      return;
    }

    for (let i = 0; i < this._layers.length; i++) {
      const L = this._layers[i];
      L.mesh.material.opacity = this.data.opacity * L.opMult;
      L.mesh.material.color.set(this.data.color);
      L.mesh.material.needsUpdate = true;
    }

    if (this._disc) {
      this._disc.material.opacity = this.data.opacity * this.data.floorOpacity;
      this._disc.material.color.set(this.data.color);
      this._disc.material.needsUpdate = true;
    }

    this._applyScale();
  },

  tick: function (t, dt) {
    if (!this._layers) return;

    const dts = Math.min(0.05, dt / 1000);
    this._tt += dts;

    // Very subtle “organic” edge breathing (breaks the geometric silhouette).
    const breathe = 1.0 + Math.sin(this._tt * 0.55) * 0.004 + Math.sin(this._tt * 0.19) * 0.003;

    for (let i = 0; i < this._layers.length; i++) {
      const L = this._layers[i];
      if (!L.tex) continue;

      const du = this.data.driftU * L.driftMul * dts;
      const dv = this.data.driftV * L.driftMul * dts;

      L.tex.offset.x = (L.tex.offset.x + du) % 1;
      L.tex.offset.y = (L.tex.offset.y + dv) % 1;

      // Apply breathing mostly to outer layers (no accumulation).
      const m = (i === 0) ? 1.0 : (1.0 + (breathe - 1.0) * (0.65 + i * 0.25));
      L.mesh.scale.set(
        this._baseRad * L.radMult * m,
        this._baseLen * L.lenMult,
        this._baseRad * L.radMult * m
      );
    }
  },

  remove: function () {
    const obj = this.el.getObject3D('beam');
    if (obj) this.el.removeObject3D('beam');

    if (this._layers) {
      this._layers.forEach(L => {
        if (L.mesh && L.mesh.material) L.mesh.material.dispose();
        if (L.tex) L.tex.dispose();
      });
    }
    if (this._contactTex) this._contactTex.dispose();
    this._layers = null;
    this._group = null;
    this._disc = null;
  }
});

// Rotates an entity so its local -Y axis points at a target entity.
// This matches the light-beam cone which extends along -Y.
    // This matches the light-beam cone which extends along -Y.
    AFRAME.registerComponent('aim-down-axis', {
      schema: { target: { type: 'selector' } },
      init: function () {
        this._vFrom = new THREE.Vector3(0, -1, 0);
        this._vTo = new THREE.Vector3();
        this._src = new THREE.Vector3();
        this._dst = new THREE.Vector3();
        this._q = new THREE.Quaternion();
      },
      tick: function () {
        const trg = this.data.target;
        if (!trg) return;

        this.el.object3D.getWorldPosition(this._src);
        trg.object3D.getWorldPosition(this._dst);

        this._vTo.copy(this._dst).sub(this._src).normalize();
        if (this._vTo.lengthSq() < 1e-6) return;

        this._q.setFromUnitVectors(this._vFrom, this._vTo);
        this.el.object3D.quaternion.copy(this._q);
      }
    });

    // Auto-matches a light-beam to an A-Frame / Three.js SpotLight.
    // It computes the cone radius from the spot angle and distance to a target.
    // (Three.js SpotLight.angle is the HALF-angle of the cone.)
    AFRAME.registerComponent('match-spotlight-cone', {
      schema: {
        light: { type: 'selector' },
        target: { type: 'selector' },
        radiusMult: { type: 'number', default: 1.0 },
        lengthMult: { type: 'number', default: 1.0 }
      },
      init: function () {
        this._o = new THREE.Vector3();
        this._t = new THREE.Vector3();
        this._lastLen = -1;
        this._lastRad = -1;
      },
      tick: function () {
        const lightEl = this.data.light;
        const targetEl = this.data.target;
        if (!lightEl || !targetEl) return;

        const threeLight = lightEl.getObject3D('light');
        if (!threeLight || !threeLight.isSpotLight) return;

        this.el.object3D.getWorldPosition(this._o);
        targetEl.object3D.getWorldPosition(this._t);

        const dist = this._o.distanceTo(this._t) * this.data.lengthMult;
        const rad = Math.tan(threeLight.angle) * dist * this.data.radiusMult;

        // Only update when it actually changes (avoids needless attribute churn).
        if (Math.abs(dist - this._lastLen) > 0.02 || Math.abs(rad - this._lastRad) > 0.02) {
          this._lastLen = dist;
          this._lastRad = rad;
          this.el.setAttribute('light-beam', {
            length: dist,
            radius: rad
          });
        }
      }
    });

    // Simple “look at” helper (no external look-at component).
    AFRAME.registerComponent('look-at-target', {
      schema: { target: { type: 'selector' } },
      init: function () {
        this._src = new THREE.Vector3();
        this._dst = new THREE.Vector3();
      },
      tick: function () {
        const trg = this.data.target;
        if (!trg) return;
        this.el.object3D.getWorldPosition(this._src);
        trg.object3D.getWorldPosition(this._dst);
        this.el.object3D.lookAt(this._dst);
      }
    });

  })();
  </script>
<style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; overflow: hidden; }
    
    /* UI Hint */
    #hint {
      position: fixed; left: 12px; bottom: 12px; z-index: 20;
      font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.85); background: rgba(0,0,0,0.45);
      padding: 8px 10px; border-radius: 10px; user-select: none;
    }
    #hint b { color: #fff; }

    /* VISUAL UPGRADE: CSS Noise for "Film Look" realism */
    .overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
    }
.grain {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAGFBMVEUAAAA5OTkAAABMTExERERmZmYzMzMyMjJOUl6NAAAACHRSTlMAwD9/cN9/QbTD42kAAABcSURBVDjLxZFBCgAhDMNs7w/2/o+1BFmQmBQE38aSNo0t1Q/60M8+aF5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0l5d0n4bWyX0wF2wygAAAABJRU5ErkJggg==");
      opacity: 0.05;
    }
  </style>

<style>
  /* ===== UI: Elevator User Guide (2D overlay, outside the 3D scene) ===== */
  #elevatorGuide {
    position: fixed;
    top: 18vh;
    right: 18px;
    width: 340px;
    max-width: min(340px, calc(100vw - 36px));
    background: rgba(0,0,0,0.78);
    color: #ffffff;
    padding: 16px 16px 14px 16px;
    border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    line-height: 1.35;
    letter-spacing: 0.2px;
    z-index: 9999;
    pointer-events: none;

    transform: translateX(120%);
    opacity: 0;
    transition: transform 240ms ease, opacity 240ms ease;
  }
  #elevatorGuide.show {
    transform: translateX(0);
    opacity: 1;
  }
  #elevatorGuide h3 {
    margin: 0 0 8px 0;
    font-size: 14px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0.92;
  }
  #elevatorGuide p {
    margin: 0 0 10px 0;
    font-size: 13px;
    opacity: 0.95;
  }
  #elevatorGuide ul {
    margin: 0;
    padding-left: 18px;
    font-size: 13px;
    opacity: 0.95;
  }
  #elevatorGuide li { margin: 6px 0; }
  #elevatorGuide .muted { opacity: 0.75; font-size: 12px; margin-top: 10px; }

  /* Keycap styling for inline “ASK” */
  #elevatorGuide .keycap{
    display:inline-block;
    padding:2px 8px;
    border-radius:6px;
    background: rgba(235,235,235,0.92);
    color: #111;
    font-weight: 700;
    font-size: 12px;
    letter-spacing: 0.10em;
    box-shadow: 0 2px 0 rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.18);
    vertical-align: 1px;
  }
  #elevatorGuide .keycap-ask{
    background: rgba(245,245,245,0.95);
  }
</style>

<link rel="icon" href="data:,">
</head>
<body>

<!-- ===== UI OVERLAY: Elevator User Guide (outside A-Frame canvas) ===== -->
<div id="elevatorGuide" aria-hidden="true">
  <h3>USER GUIDE</h3>
  <p>You're close to the elevator. You can call it using the button.</p>
  <ul>
    <li><strong>Move:</strong> WASD / Arrow Keys</li>
    <li><strong>Look:</strong> Mouse</li>
        <li><strong>Unlock mouse:</strong> Press <strong>ESC</strong> to release the cursor</li>
<li><strong>Interact:</strong> Press <span class="keycap keycap-ask">ASK</span> to enable clicks, then click the call button</li>
    <li><strong>Elevator:</strong> Press the button to open/close doors</li>
  </ul>
  <p class="muted">Step back to dismiss this guide.</p>
</div>
<!-- ===== END UI OVERLAY ===== -->

<div id="hint" style="display:none"></div>
<div class="overlay grain"></div>
<a-scene tabindex="0" background="color: #020202" fog="type: exponential; color: #050505; density: 0.00022" renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; exposure: 0.92; highRefreshRate: true;" s4-mercury-manager="" shadow="type: pcfsoft; autoUpdate: true;" vr-mode-ui="enabled: false">
<a-assets timeout="3000">
<video autoplay="" crossorigin="anonymous" id="fearVideo" loop="" playsinline="" preload="metadata" src="fear-room/video/test-video.mp4" webkit-playsinline="">
<source src="fear-room/video/test-video.mp4" type="video/mp4"/>
</video>
<audio crossorigin="anonymous" id="fearAudio" loop="" preload="none">
<source src="fear-room/video/test-video.mp4" type="audio/mp4"/>
</audio>
<audio crossorigin="anonymous" id="fearRoomMusic" loop preload="none">
  <source src="fear-room/music/fear_room_music/fear_room_music.mp3" type="audio/mpeg"/>
</audio>

<!-- Station 3 panel textures -->
<img id="station3_A1" crossorigin="anonymous" src="fear-room/assets/station3_A1.png"/>
<img id="station3_B1" crossorigin="anonymous" src="fear-room/assets/station3_B1.png"/>
<img id="station3_B2" crossorigin="anonymous" src="fear-room/assets/station3_B2.png"/>
<img id="station3_B3" crossorigin="anonymous" src="fear-room/assets/station3_B3.png"/>
<img id="station3_B4" crossorigin="anonymous" src="fear-room/assets/station3_B4.png"/>
<img id="station3_B5" crossorigin="anonymous" src="fear-room/assets/station3_B5.png"/>
<img id="station3_C1" crossorigin="anonymous" src="fear-room/assets/station3_C1.png"/>
<!-- Wall panel textures -->
<img crossorigin="anonymous" id="Wall2Tex" src="fear-room/assets/Wall2.png"/>
<img crossorigin="anonymous" id="Wall2BTex" src="fear-room/assets/Wall2B.png"/>
<!-- Concrete PBR textures (floor + ceiling only) -->
<img crossorigin="anonymous" id="conc_base" src="fear-room/textures/CONCRETE%20WALL/concrete_basecolor.jpg"/>
<img crossorigin="anonymous" id="conc_norm" src="fear-room/textures/CONCRETE%20WALL/concrete_normal.jpg"/>
<img crossorigin="anonymous" id="conc_rough" src="fear-room/textures/CONCRETE%20WALL/concrete_roughness.jpg"/>
<a-mixin id="matConcreteWallsCeiling" material="shader: standard; src: #conc_base; normalMap: #conc_norm; roughnessMap: #conc_rough;
                  normalScale: 1 1; metalness: 0.0; roughness: 0.65; color: #0b0b0b; repeat: 4 4">
</a-mixin>
<img crossorigin="anonymous" id="VideoLabel_240x480" src="fear-room/assets/VideoLabel_240x480.png"/>
<!-- Network label texture -->
<img crossorigin="anonymous" id="NetworkLabel_1200w" src="fear-room/assets/NetworkLabel_1200w.png"/>
<!-- Station 4: table contents textures -->
<img crossorigin="anonymous" id="s4_extract_redacted_01" src="fear-room/assets/station_04_assets/s4_extract_redacted_01.png"/>
<img crossorigin="anonymous" id="s4_extract_redacted_02" src="fear-room/assets/station_04_assets/s4_extract_redacted_02.png"/>
<img crossorigin="anonymous" id="s4_extract_redacted_03" src="fear-room/assets/station_04_assets/s4_extract_redacted_03.png"/>
<img crossorigin="anonymous" id="s4_folder_final" src="fear-room/assets/station_04_assets/s4_folder_final.png"/>
<img crossorigin="anonymous" id="s4_folder_initiative" src="fear-room/assets/station_04_assets/s4_folder_initiative.png"/>
<img crossorigin="anonymous" id="s4_folder_midterm" src="fear-room/assets/station_04_assets/s4_folder_midterm.png"/>
<img crossorigin="anonymous" id="s4_label_card" src="fear-room/assets/station_04_assets/s4_label_card.png"/>
<img crossorigin="anonymous" id="s4_packet_outcome_review_2034" src="fear-room/assets/station_04_assets/s4_packet_outcome_review_2034.png"/>
<img crossorigin="anonymous" id="s4_packet_policybrief_2026" src="fear-room/assets/station_04_assets/s4_packet_policybrief_2026.png"/>
<img crossorigin="anonymous" id="s4_sheet_errata" src="fear-room/assets/station_04_assets/s4_sheet_errata.png"/>
<!-- Station 4: wall panel textures -->
<img crossorigin="anonymous" id="s4_wall_A1_promise" src="fear-room/assets/station_04_assets/wall_panel_assets/s4_wall_A1_promise.png"/>
<img crossorigin="anonymous" id="s4_wall_A2_enrolment" src="fear-room/assets/station_04_assets/wall_02_assets/s4_wall_A2_enrolment.png"/>
<img crossorigin="anonymous" id="s4_wall_A3_completion" src="fear-room/assets/station_04_assets/wall_3_assets/s4_wall_A3_completion.png"/>
<img crossorigin="anonymous" id="s4_wall_A4_time_mismatch" src="fear-room/assets/station_04_assets/wall_4_asset/s4_wall_A4_time_mismatch.png"/>
<img crossorigin="anonymous" id="s4_wall_A5_earnings_recovery" src="fear-room/assets/station_04_assets/wall_5_asset/s4_wall_A5_earnings_recovery.png"/>
<img crossorigin="anonymous" id="s4_wall_A6_cost_transfer" src="fear-room/assets/station_04_assets/wall_6_assets/s4_wall_A6_cost_transfer.png"/>
<!-- Station 4 carpet PBR textures -->
<img crossorigin="anonymous" id="carpet_base" src="fear-room/textures/fabric_carpet/fabric_basecolor.jpg"/>
<img crossorigin="anonymous" id="carpet_normal" src="fear-room/textures/fabric_carpet/fabric_normal.jpg"/>
<img crossorigin="anonymous" id="carpet_rough" src="fear-room/textures/fabric_carpet/fabric_roughness.jpg"/>
<!-- Station 4: wall text / gallery label (right of monolith) -->
<img crossorigin="anonymous" id="s4_station_text" src="fear-room/assets/station_04_text.png"/>
<img crossorigin="anonymous" id="fear_painting_tex" src="fear-room/assets/PAINTING.png"/>
<img crossorigin="anonymous" id="painting_label_tex" src="fear-room/assets/painting_label.png"/>
<img crossorigin="anonymous" id="station5_B_ownership_control_register_2048x2960" src="fear-room/assets/station_05_assets/station5_B_ownership-control-register_2048x2960.png"/>
<img crossorigin="anonymous" id="station5_C_lobbying_policy_timeline_2048x2960" src="fear-room/assets/station_05_assets/station5_C_lobbying-policy-timeline_2048x2960.png"/>
<img crossorigin="anonymous" id="station5_A_authority_trace_2048x2960" src="fear-room/assets/station_05_assets/station5_A_authority-trace_2048x2960.png"/>

<img crossorigin="anonymous" id="station5_D_accountability_register_3072x2160" src="fear-room/assets/station_05_assets/station5_D_accountability-register_3072x2160.png"/>
<!-- Photography corridor photos -->
<img id="corridorPhoto01" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_01.jpg"/>
<img id="corridorPhoto02" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_02.jpg"/>
<img id="corridorPhoto04" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_04.jpg"/>
<img id="corridorPhoto05" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_05.jpg"/>
<img id="corridorPhoto06" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_06.jpg"/>
<img id="corridorPhoto07" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_07.jpg"/>
<img id="corridorPhoto08" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_08.jpg"/>
<img id="corridorPhoto09" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_09.jpg"/>
<img id="corridorPhoto10" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_10.jpg"/>
<img id="corridorPhoto11" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_11.jpg"/>
<img id="corridorPhoto12" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_12.jpg"/>
<img id="corridorPhoto13" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_13.jpg"/>
<img id="corridorPhoto14" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_14.jpg"/>
<img id="corridorPhoto15" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_15.jpg"/>
<img id="corridorPhoto16" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_16.jpg"/>
<img id="corridorPhoto17" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_17.jpg"/>

<img id="corridorPhoto18" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/Photo_18.jpg"/>


<!-- Corridor photo labels -->
<img id="corridorPhoto01Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_01_label.png"/>
<img id="corridorPhoto02Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_02_label.png"/>
<img id="corridorPhoto04Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_04_label.png"/>
<img id="corridorPhoto05Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_05_label.png"/>
<img id="corridorPhoto06Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_06_label.png"/>
<img id="corridorPhoto07Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_07_label.png"/>
<img id="corridorPhoto08Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_08_label.png"/>
<img id="corridorPhoto09Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_09_label.png"/>
<img id="corridorPhoto10Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_10_label.png"/>
<img id="corridorPhoto11Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_11_label.png"/>
<img id="corridorPhoto12Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_12_label.png"/>
<img id="corridorPhoto13Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_13_label.png"/>
<img id="corridorPhoto14Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_14_label.png"/>
<img id="corridorPhoto15Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_15_label.png"/>
<img id="corridorPhoto16Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_16_label.png"/>
<img id="corridorPhoto17Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_17_label.png"/>
<img id="corridorPhoto18Label" crossorigin="anonymous" src="fear-room/assets/photography%20corridor/photo_labels/photo_18_label.png"/>
<img crossorigin="anonymous" id="photo_label_tex" src="fear-room/assets/photo_label.png"/>

<a-asset-item id="smartphoneGLB" crossorigin="anonymous" src="fear-room/assets/station_05_assets/smartphone.glb"></a-asset-item>
</a-assets>
<a-entity light="type: ambient; intensity: 0.12; color: #ccdbff"></a-entity>
<a-entity light="type: directional; intensity: 0.75; color: #f0f0ff; castShadow: true; shadowBias: -0.001; shadowMapHeight: 2048; shadowMapWidth: 2048" position="6 10 8"></a-entity>
<a-entity light="type: directional; intensity: 0.28; color: #aab; castShadow: false" position="-8 9 -10"></a-entity>
<a-plane id="mainFloor" height="38" material="repeat: 5.333333 5.066667" mixin="matConcreteWallsCeiling" position="12 0 11" rotation="-90 0 0" width="24"></a-plane>
<a-plane id="mainCeiling" height="30" material="side: double; repeat: 8 10" mixin="matConcreteWallsCeiling" position="12 6 15" rotation="90 0 0" width="24"></a-plane>
<a-plane height="8" material="repeat: 6 10" mixin="matConcreteWallsCeiling" position="9 2.2 -4" rotation="90 0 0" width="3"></a-plane>

<a-box class="collider" depth="30" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="-0.06 2 15" width="0.12"></a-box>
<a-plane class="architectural-object" height="3.5" id="projection_screen_station_1" material="shader: standard; color: #0B0B0B; roughness: 0.9; metalness: 0.0; emissive: #000000; emissiveIntensity: 0.0; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -4" position="0.03 2.25 10.0" rotation="0 90 0" screen-always-on="video: #fearVideo; audio: #fearVideo; spillLight: #projectionSpill1; spillIntensity: 2.6; spillDistance: 6.5; spillAngle: 55; spillPenumbra: 0.9; spillPoint: #projectionFill1; pointIntensity: 0.45; pointDistance: 6.5" screen-surface="src: #fearVideo; maxLuma: 1.0; gain: 2.2; contrast: 1.1; brightness: 1.02; saturation: 1.05" width="12.0">
<a-entity id="projectionSpill1" light="type: spot; color: #ffffff; intensity: 0.0; angle: 55; penumbra: 0.9; distance: 10; decay: 2; castShadow: false" position="0 0 0.08" rotation="0 180 0"></a-entity>
<a-entity id="projectionFill1" light="type: point; color: #ffffff; intensity: 0.0; distance: 6.5; decay: 2; castShadow: false" position="0 0 0.14"></a-entity>
</a-plane>
<!-- Projection Station 1 label image -->
<a-plane height="2.4" id="projection_label_station_1" material="shader: flat; src: #VideoLabel_240x480; transparent: true; opacity: 1; side: double; depthWrite: false; depthTest: true; polygonOffset: true; polygonOffsetFactor: -4; polygonOffsetUnits: -4" position="0.1 1.5 2.00" rotation="0 90 0" width="1.2"></a-plane>
<!-- Network station label -->
<a-plane height="2.4" id="network_label" material="shader: flat; src: #NetworkLabel_1200w; transparent: true; opacity: 1; side: double; depthWrite: false; depthTest: true; polygonOffset: true; polygonOffsetFactor: -4; polygonOffsetUnits: -4" position="4 1.5 17.998" rotation="0 180 0" width="1.2"></a-plane>
<a-box class="collider" depth="0.12" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="12 2 30.06" width="24"></a-box>
<a-box class="collider" depth="0.12" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="4 2 -0.06" width="8"></a-box>
<a-box class="collider" depth="0.12" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="14 2 -0.06" width="8"></a-box>
<a-box class="collider" depth="24" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="18.06 2 12" width="0.12"></a-box>
<!-- Right wall segment (z 0 → 24) -->
<a-box class="collider" depth="24" height="4"
       material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true"
       position="24 2 12" width="0.12"></a-box>

<!-- Closing wall (x 18 → 24) at z = 18 -->
<a-entity id="elevator1_wall_hole_patch" position="21 2 18.06">
  <!-- Wall patch with doorway cut-out for the elevator opening (opening W=2.60m, H=2.70m, centered at x=+0.10) -->
  <!-- Left panel (x: -3.00 → -1.20) -->
  <a-box class="collider" depth="0.12" height="4"
         material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true"
         position="-2.10 0 0" width="1.80"></a-box>

  <!-- Right panel (x: +1.40 → +3.00) -->
  <a-box class="collider" depth="0.12" height="4"
         material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true"
         position="2.20 0 0" width="1.60"></a-box>

  <!-- Header panel above the doorway (y: 2.70 → 4.00) -->
  <a-box depth="0.12" height="1.30"
         material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true"
         position="0.10 1.35 0" width="2.60"></a-box>
</a-entity>

  <!-- ===== INSERTED: INDUSTRIAL ELEVATOR ===== -->
<a-entity id="industrial_elevator_1"
          position="21.1 0 17.595"
          rotation="0 0 0"
          elevator-toggle>
  <!-- Elevator geometry (revised): clean doorway, deeper cab, player can enter. -->

  <!-- ===== CAB (deeper) ===== -->
  <!-- Door plane aligns to wall plane at world z=18.06 (local z=0.465) -->
  <a-entity id="elevator1_cab">
    <!-- Floor / ceiling (no front overlap; cab starts slightly behind door plane) -->
    <a-box id="elevator1_cab_floor"
           width="2.70" height="0.06" depth="2.55"
           position="0 0.03 -0.835"
           material="shader: standard; color: #070707; roughness: 0.95; metalness: 0.10"></a-box>

    <a-box id="elevator1_cab_ceiling"
           width="2.70" height="0.06" depth="2.55"
           position="0 2.73 -0.835"
           material="shader: standard; color: #070707; roughness: 0.95; metalness: 0.10"></a-box>

    <!-- Back wall (collider) -->
    <a-box id="elevator1_cab_back" class="collider"
           width="2.70" height="2.70" depth="0.04"
           position="0 1.35 -2.13"
           material="shader: standard; color: #0b0b0b; roughness: 0.92; metalness: 0.08"></a-box>

    <!-- Side walls (colliders) -->
    <a-box id="elevator1_cab_side_L" class="collider"
           width="0.04" height="2.70" depth="2.55"
           position="-1.35 1.35 -0.835"
           material="shader: standard; color: #0b0b0b; roughness: 0.92; metalness: 0.08"></a-box>

    <a-box id="elevator1_cab_side_R" class="collider"
           width="0.04" height="2.70" depth="2.55"
           position="1.35 1.35 -0.835"
           material="shader: standard; color: #0b0b0b; roughness: 0.92; metalness: 0.08"></a-box>

    <!-- Subtle rear panel highlight -->
    <a-plane id="elevator1_cab_back_panel"
             width="2.20" height="2.10"
             position="0 1.35 -2.09" rotation="0 180 0"
             material="shader: standard; color: #101010; roughness: 0.75; metalness: 0.20; side: double; polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1"></a-plane>
  </a-entity>

  <!-- ===== DOORWAY FRAME (flush to wall) ===== -->
  <!-- Frame plane sits on local z=0.455 so the front face lands on z=0.465 (wall plane). -->
  <a-box id="elevator1_frame_jamb_L"
         width="0.18" height="2.70" depth="0.02"
         position="-1.21 1.35 0.517"
         material="shader: standard; color: #161616; roughness: 0.55; metalness: 0.40; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-box>

  <a-box id="elevator1_frame_jamb_R"
         width="0.18" height="2.70" depth="0.02"
         position="1.21 1.35 0.517"
         material="shader: standard; color: #161616; roughness: 0.55; metalness: 0.40; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-box>

  <a-box id="elevator1_frame_lintel"
         width="2.96" height="0.22" depth="0.02"
         position="0 2.59 0.517"
         material="shader: standard; color: #161616; roughness: 0.55; metalness: 0.40; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-box>

  <!-- Side pockets (visual housings for doors to 'disappear' into) -->
  <a-box id="elevator1_pocket_L"
         width="0.28" height="2.70" depth="0.30"
         position="-1.44 1.35 0.28"
         material="shader: standard; color: #0f0f0f; roughness: 0.70; metalness: 0.25"></a-box>

  <a-box id="elevator1_pocket_R"
         width="0.28" height="2.70" depth="0.30"
         position="1.44 1.35 0.28"
         material="shader: standard; color: #0f0f0f; roughness: 0.70; metalness: 0.25"></a-box>

  <!-- ===== SPLIT DOORS (slide sideways; fade instantly so you don't see the motion) ===== -->
  <a-box id="elevator1_door_L"
         width="1.292" height="2.70" depth="0.03"
         position="-0.654 1.35 0.49"
         material="shader: standard; color: #0b0b0b; roughness: 0.45; metalness: 0.35; polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1"
         animation__open_pos="property: position; to: -1.95 1.35 0.49; dur: 520; easing: easeInOutQuad; startEvents: elevator1-open"
         animation__close_pos="property: position; to: -0.654 1.35 0.49; dur: 520; easing: easeInOutQuad; startEvents: elevator1-close"></a-box>

  <a-box id="elevator1_door_R"
         width="1.292" height="2.70" depth="0.03"
         position="0.654 1.35 0.49"
         material="shader: standard; color: #0b0b0b; roughness: 0.45; metalness: 0.35; polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1"
         animation__open_pos="property: position; to: 1.95 1.35 0.49; dur: 520; easing: easeInOutQuad; startEvents: elevator1-open"
         animation__close_pos="property: position; to: 0.654 1.35 0.49; dur: 520; easing: easeInOutQuad; startEvents: elevator1-close"></a-box>

  <!-- Door seam (visible only when doors are closed) -->

<!-- ===== CALL BUTTON (outside, right jamb) ===== -->
  <a-entity id="elevator1_call_panel" position="1.62 1.10 0.61">
    <a-box id="elevator1_call_plate"
           width="0.18" height="0.38" depth="0.02"
           material="shader: standard; color: #161616; roughness: 0.55; metalness: 0.40; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-box>

    <a-cylinder id="elevator1_call_button" class="clickable"
                radius="0.032" height="0.02"
                position="0 0.02 0.013" rotation="90 0 0"
                material="shader: standard; color: #cfcfcf; roughness: 0.4; metalness: 0.6; emissive: #ffffff; emissiveIntensity: 0.0"
                onclick="document.querySelector('#elevator1_call_light').emit('blink'); document.querySelector('#industrial_elevator_1').emit('elevator1-toggle');"></a-cylinder>

    <a-sphere id="elevator1_call_light"
              radius="0.012" position="0 0.092 0.013"
              material="shader: standard; color: #0a0a0a; emissive: #ffffff; emissiveIntensity: 0.0; roughness: 0.9; metalness: 0.0"
              animation__blink="property: material.emissiveIntensity; to: 1.0; dur: 120; dir: alternate; loop: 6; startEvents: blink"></a-sphere>
    

  </a-entity>
</a-entity>
  <!-- ===== END INSERTED: INDUSTRIAL ELEVATOR ===== -->



<!-- Right wall extension (z 24 → 30) to close the corner -->
<a-box class="collider" depth="6" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="24 2 27" width="0.12"></a-box>
<!-- Station 5: Ownership/control register panel -->
<a-plane id="station5_B_ownership_control_register_panel"
         width="1.8" height="2.602"
         position="23.9 2 28.5"
         rotation="0 -90 0"
         material="shader: flat; src: #station5_B_ownership_control_register_2048x2960; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
</a-plane>

<!-- Station 5: Lobbying policy timeline panel -->
<a-plane id="station5_C_lobbying_policy_timeline_panel"
         width="1.8" height="2.602"
         position="23.9 2 26.5"
         rotation="0 -90 0"
         material="shader: flat; src: #station5_C_lobbying_policy_timeline_2048x2960; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
</a-plane>




<!-- Station 5: Accountability register panel -->
<a-plane id="station5_D_accountability_register_panel"
         width="2.6" height="1.83"
         position="20.15 2 29.9"
         rotation="0 180 0"
         material="shader: flat; src: #station5_D_accountability_register_3072x2160; transparent: true; alphaTest: 0.01; side: double; depthTest: true; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
</a-plane>

<!-- Station 5D: plinth + phone pile (under Accountability) -->
<a-box id="station5_D_accountability_plinth" class="collider"
       width="2.6" height="0.4" depth="0.6"
       position="20.15 0.2 29.55"
       material="shader: standard; color: #0b0b0b; roughness: 0.85; metalness: 0.08"
       shadow="cast: true; receive: true">
</a-box>


<a-box id="station5_D_phone_pile_collider"
       class="collider"
       width="2.3" height="0.32" depth="0.8"
       position="20.15 0.56 29.55"
       material="opacity: 0; transparent: true"
       shadow="cast: false; receive: false">
</a-box>

<a-entity id="station5_D_phone_pile" position="20.15 0.4 29.55" rotation="0 180 0">
  <!-- phone bundle: flat phones stacked into a compact mound on the plinth surface -->
  <a-entity id="station5_D_phone_001" gltf-model="#smartphoneGLB" position="0.406 0.012 -0.147" rotation="-90.6 155.9 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_002" gltf-model="#smartphoneGLB" position="-0.006 0.012 0.002" rotation="-89.6 72.1 -1.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_003" gltf-model="#smartphoneGLB" position="0.058 0.012 -0.095" rotation="-91.0 211.9 178.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_004" gltf-model="#smartphoneGLB" position="-0.758 0.012 0.080" rotation="-90.5 285.9 -0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_005" gltf-model="#smartphoneGLB" position="-0.333 0.012 -0.024" rotation="-89.2 59.8 178.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_006" gltf-model="#smartphoneGLB" position="-0.349 0.012 -0.151" rotation="-89.4 13.0 -1.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_007" gltf-model="#smartphoneGLB" position="0.093 0.012 -0.039" rotation="-90.7 146.4 178.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_008" gltf-model="#smartphoneGLB" position="-0.912 0.012 -0.094" rotation="-90.0 314.7 181.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_009" gltf-model="#smartphoneGLB" position="0.538 0.012 -0.040" rotation="-89.3 276.6 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_010" gltf-model="#smartphoneGLB" position="0.675 0.012 0.071" rotation="-89.0 286.4 179.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_011" gltf-model="#smartphoneGLB" position="0.419 0.012 0.093" rotation="-90.4 68.8 180.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_012" gltf-model="#smartphoneGLB" position="0.877 0.012 0.007" rotation="-89.6 265.7 -1.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_013" gltf-model="#smartphoneGLB" position="-0.467 0.012 0.069" rotation="-90.7 225.0 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_014" gltf-model="#smartphoneGLB" position="0.061 0.012 0.189" rotation="-89.1 60.7 179.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_015" gltf-model="#smartphoneGLB" position="0.640 0.012 -0.089" rotation="-89.7 72.9 181.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_016" gltf-model="#smartphoneGLB" position="-0.934 0.012 -0.015" rotation="-90.8 299.0 0.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_017" gltf-model="#smartphoneGLB" position="-0.410 0.012 0.151" rotation="-89.7 104.6 -1.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_018" gltf-model="#smartphoneGLB" position="-0.730 0.012 0.123" rotation="-90.6 295.5 -0.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_019" gltf-model="#smartphoneGLB" position="-0.576 0.012 0.013" rotation="-90.7 108.4 179.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_020" gltf-model="#smartphoneGLB" position="0.483 0.012 -0.002" rotation="-90.0 155.9 179.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_021" gltf-model="#smartphoneGLB" position="-0.179 0.012 0.034" rotation="-89.7 43.8 181.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_022" gltf-model="#smartphoneGLB" position="-0.954 0.012 0.055" rotation="-89.3 283.9 1.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_023" gltf-model="#smartphoneGLB" position="0.928 0.012 0.087" rotation="-89.2 103.7 180.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_024" gltf-model="#smartphoneGLB" position="0.131 0.012 -0.183" rotation="-90.9 249.9 0.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_025" gltf-model="#smartphoneGLB" position="0.496 0.012 0.040" rotation="-90.4 315.8 0.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_026" gltf-model="#smartphoneGLB" position="0.080 0.012 0.100" rotation="-89.3 176.9 -1.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_027" gltf-model="#smartphoneGLB" position="-0.515 0.012 -0.120" rotation="-90.2 163.8 1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_028" gltf-model="#smartphoneGLB" position="0.240 0.012 0.026" rotation="-89.5 239.9 -0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_029" gltf-model="#smartphoneGLB" position="-0.192 0.012 0.134" rotation="-90.8 161.6 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_030" gltf-model="#smartphoneGLB" position="-0.480 0.012 -0.054" rotation="-90.8 178.3 1.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_031" gltf-model="#smartphoneGLB" position="0.602 0.012 0.148" rotation="-89.7 88.1 0.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_032" gltf-model="#smartphoneGLB" position="0.342 0.012 -0.083" rotation="-90.1 163.2 -0.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_033" gltf-model="#smartphoneGLB" position="1.075 0.012 -0.036" rotation="-89.0 269.4 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_034" gltf-model="#smartphoneGLB" position="0.694 0.012 -0.145" rotation="-90.9 178.3 180.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_035" gltf-model="#smartphoneGLB" position="-0.410 0.012 0.108" rotation="-89.2 355.1 180.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_036" gltf-model="#smartphoneGLB" position="-1.014 0.012 -0.056" rotation="-89.6 9.2 178.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_037" gltf-model="#smartphoneGLB" position="-0.173 0.012 0.075" rotation="-90.1 111.9 178.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_038" gltf-model="#smartphoneGLB" position="0.323 0.012 0.130" rotation="-89.1 343.3 -0.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_039" gltf-model="#smartphoneGLB" position="-0.128 0.012 -0.065" rotation="-90.6 169.7 179.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_040" gltf-model="#smartphoneGLB" position="0.259 0.012 0.064" rotation="-89.7 212.1 181.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_041" gltf-model="#smartphoneGLB" position="0.899 0.012 -0.064" rotation="-89.5 179.5 0.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_042" gltf-model="#smartphoneGLB" position="0.138 0.012 -0.136" rotation="-89.6 138.0 180.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_043" gltf-model="#smartphoneGLB" position="-0.662 0.012 -0.030" rotation="-90.8 186.5 -0.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_044" gltf-model="#smartphoneGLB" position="-0.109 0.012 -0.159" rotation="-89.5 39.4 -0.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_045" gltf-model="#smartphoneGLB" position="-0.214 0.012 0.178" rotation="-90.1 40.7 1.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_046" gltf-model="#smartphoneGLB" position="-0.822 0.012 0.020" rotation="-89.3 332.4 181.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_047" gltf-model="#smartphoneGLB" position="-0.246 0.012 -0.102" rotation="-90.0 26.8 0.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_048" gltf-model="#smartphoneGLB" position="0.710 0.012 0.114" rotation="-90.5 119.6 1.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_049" gltf-model="#smartphoneGLB" position="-0.749 0.012 -0.131" rotation="-90.3 154.8 180.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_050" gltf-model="#smartphoneGLB" position="0.771 0.012 -0.032" rotation="-90.0 214.8 181.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_051" gltf-model="#smartphoneGLB" position="0.960 0.012 0.049" rotation="-90.3 181.5 0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_052" gltf-model="#smartphoneGLB" position="-0.669 0.012 -0.076" rotation="-90.0 348.6 0.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_053" gltf-model="#smartphoneGLB" position="-1.059 0.012 0.020" rotation="-91.0 13.3 -0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_054" gltf-model="#smartphoneGLB" position="0.026 0.012 0.147" rotation="-90.3 95.2 180.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_055" gltf-model="#smartphoneGLB" position="0.266 0.012 0.172" rotation="-90.9 215.2 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_056" gltf-model="#smartphoneGLB" position="0.051 0.012 0.047" rotation="-90.5 75.1 -1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_057" gltf-model="#smartphoneGLB" position="0.310 0.012 -0.026" rotation="-90.1 156.9 -0.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_058" gltf-model="#smartphoneGLB" position="0.842 0.012 -0.109" rotation="-90.8 249.4 -1.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_059" gltf-model="#smartphoneGLB" position="1.107 0.012 0.006" rotation="-90.7 309.0 -1.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_060" gltf-model="#smartphoneGLB" position="-0.576 0.012 -0.158" rotation="-90.1 15.1 0.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_061" gltf-model="#smartphoneGLB" position="-0.605 0.032 0.079" rotation="-89.7 242.2 -1.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_062" gltf-model="#smartphoneGLB" position="0.275 0.032 -0.132" rotation="-90.7 141.9 179.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_063" gltf-model="#smartphoneGLB" position="-0.464 0.032 -0.065" rotation="-90.7 89.5 0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_064" gltf-model="#smartphoneGLB" position="-0.032 0.032 -0.142" rotation="-89.2 268.2 1.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_065" gltf-model="#smartphoneGLB" position="0.538 0.032 0.036" rotation="-89.7 289.4 181.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_066" gltf-model="#smartphoneGLB" position="-0.074 0.032 -0.031" rotation="-89.0 5.9 181.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_067" gltf-model="#smartphoneGLB" position="0.138 0.032 -0.008" rotation="-89.4 340.4 -1.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_068" gltf-model="#smartphoneGLB" position="0.541 0.032 0.092" rotation="-91.0 150.6 -0.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_069" gltf-model="#smartphoneGLB" position="0.784 0.032 -0.034" rotation="-89.8 0.1 178.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_070" gltf-model="#smartphoneGLB" position="-0.790 0.032 0.002" rotation="-89.1 47.3 178.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_071" gltf-model="#smartphoneGLB" position="-0.211 0.032 0.058" rotation="-90.0 136.5 1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_072" gltf-model="#smartphoneGLB" position="-0.506 0.032 -0.007" rotation="-89.4 272.8 -1.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_073" gltf-model="#smartphoneGLB" position="0.765 0.032 0.053" rotation="-90.2 195.8 -0.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_074" gltf-model="#smartphoneGLB" position="0.150 0.032 0.067" rotation="-90.6 160.2 180.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_075" gltf-model="#smartphoneGLB" position="-0.218 0.032 -0.112" rotation="-90.7 356.3 179.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_076" gltf-model="#smartphoneGLB" position="0.691 0.032 -0.080" rotation="-89.6 64.9 0.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_077" gltf-model="#smartphoneGLB" position="0.534 0.032 -0.016" rotation="-90.3 117.6 181.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_078" gltf-model="#smartphoneGLB" position="0.499 0.032 -0.099" rotation="-89.6 33.6 -0.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_079" gltf-model="#smartphoneGLB" position="0.051 0.032 0.031" rotation="-89.4 227.9 1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_080" gltf-model="#smartphoneGLB" position="-0.272 0.032 -0.041" rotation="-89.7 69.6 1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_081" gltf-model="#smartphoneGLB" position="-0.662 0.032 -0.068" rotation="-90.4 337.6 180.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_082" gltf-model="#smartphoneGLB" position="0.150 0.032 -0.073" rotation="-90.1 120.9 1.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_083" gltf-model="#smartphoneGLB" position="-0.394 0.032 0.034" rotation="-89.9 125.2 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_084" gltf-model="#smartphoneGLB" position="-0.189 0.032 0.110" rotation="-90.7 224.0 -0.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_085" gltf-model="#smartphoneGLB" position="0.314 0.032 -0.035" rotation="-89.1 160.8 178.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_086" gltf-model="#smartphoneGLB" position="-0.819 0.032 -0.032" rotation="-90.9 31.1 -0.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_087" gltf-model="#smartphoneGLB" position="-0.198 0.032 -0.073" rotation="-90.6 138.5 181.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_088" gltf-model="#smartphoneGLB" position="-0.477 0.032 0.106" rotation="-89.1 77.4 0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_089" gltf-model="#smartphoneGLB" position="-0.691 0.032 0.036" rotation="-89.5 89.8 -0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_090" gltf-model="#smartphoneGLB" position="-0.467 0.032 -0.106" rotation="-90.0 74.5 0.1" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_091" gltf-model="#smartphoneGLB" position="-0.003 0.032 0.095" rotation="-89.9 269.3 180.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_092" gltf-model="#smartphoneGLB" position="0.314 0.032 0.041" rotation="-90.2 244.6 179.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_093" gltf-model="#smartphoneGLB" position="0.234 0.032 0.110" rotation="-90.8 0.6 180.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_094" gltf-model="#smartphoneGLB" position="0.326 0.032 0.002" rotation="-90.5 244.8 180.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_095" gltf-model="#smartphoneGLB" position="0.070 0.032 0.142" rotation="-89.5 297.9 0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_096" gltf-model="#smartphoneGLB" position="0.339 0.052 -0.001" rotation="-89.9 228.7 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_097" gltf-model="#smartphoneGLB" position="0.016 0.052 -0.031" rotation="-90.1 178.9 181.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_098" gltf-model="#smartphoneGLB" position="-0.451 0.052 -0.021" rotation="-89.2 119.5 0.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_099" gltf-model="#smartphoneGLB" position="-0.035 0.052 -0.100" rotation="-90.8 258.4 1.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_100" gltf-model="#smartphoneGLB" position="-0.125 0.052 0.031" rotation="-89.9 82.6 180.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_101" gltf-model="#smartphoneGLB" position="-0.176 0.052 -0.025" rotation="-90.9 63.4 180.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_102" gltf-model="#smartphoneGLB" position="-0.058 0.052 -0.068" rotation="-89.8 315.5 181.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_103" gltf-model="#smartphoneGLB" position="0.179 0.052 0.013" rotation="-90.5 43.1 181.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_104" gltf-model="#smartphoneGLB" position="-0.342 0.052 -0.084" rotation="-89.0 219.1 180.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_105" gltf-model="#smartphoneGLB" position="-0.490 0.052 0.052" rotation="-90.8 174.2 181.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_106" gltf-model="#smartphoneGLB" position="-0.294 0.052 -0.051" rotation="-90.0 63.8 181.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_107" gltf-model="#smartphoneGLB" position="-0.314 0.052 0.013" rotation="-89.4 19.5 180.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_108" gltf-model="#smartphoneGLB" position="0.259 0.052 -0.055" rotation="-89.2 164.1 179.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_109" gltf-model="#smartphoneGLB" position="0.269 0.052 -0.096" rotation="-89.2 97.8 -0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_110" gltf-model="#smartphoneGLB" position="0.214 0.052 0.087" rotation="-89.9 284.9 180.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_111" gltf-model="#smartphoneGLB" position="0.512 0.052 -0.020" rotation="-89.0 164.8 0.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_112" gltf-model="#smartphoneGLB" position="-0.515 0.052 -0.067" rotation="-90.3 313.9 -1.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_113" gltf-model="#smartphoneGLB" position="-0.093 0.052 0.100" rotation="-89.4 292.1 179.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_114" gltf-model="#smartphoneGLB" position="0.483 0.052 -0.060" rotation="-89.6 223.5 178.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_115" gltf-model="#smartphoneGLB" position="-0.016 0.052 0.063" rotation="-90.7 326.9 -0.0" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_116" gltf-model="#smartphoneGLB" position="0.189 0.052 0.053" rotation="-90.2 119.9 1.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_117" gltf-model="#smartphoneGLB" position="0.003 0.052 0.007" rotation="-91.0 8.6 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_118" gltf-model="#smartphoneGLB" position="-0.115 0.072 -0.007" rotation="-90.8 278.9 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_119" gltf-model="#smartphoneGLB" position="0.112 0.072 -0.004" rotation="-90.2 52.6 181.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_120" gltf-model="#smartphoneGLB" position="-0.141 0.072 -0.039" rotation="-90.0 128.5 181.2" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_121" gltf-model="#smartphoneGLB" position="0.166 0.072 -0.056" rotation="-89.7 159.9 -1.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_122" gltf-model="#smartphoneGLB" position="0.170 0.072 0.031" rotation="-89.7 162.6 0.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_123" gltf-model="#smartphoneGLB" position="-0.029 0.072 0.034" rotation="-90.8 62.0 178.9" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_124" gltf-model="#smartphoneGLB" position="0.310 0.072 0.016" rotation="-89.9 109.9 -0.6" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_125" gltf-model="#smartphoneGLB" position="-0.333 0.072 -0.013" rotation="-90.6 105.4 -1.8" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_126" gltf-model="#smartphoneGLB" position="0.371 0.072 -0.009" rotation="-90.0 129.8 -1.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_127" gltf-model="#smartphoneGLB" position="-0.224 0.072 0.025" rotation="-91.0 137.5 178.3" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_128" gltf-model="#smartphoneGLB" position="-0.019 0.072 -0.063" rotation="-89.2 212.5 180.7" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_129" gltf-model="#smartphoneGLB" position="0.090 0.072 0.057" rotation="-90.0 216.5 1.5" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_130" gltf-model="#smartphoneGLB" position="0.022 0.072 -0.029" rotation="-89.9 128.0 178.4" scale="0.084 0.084 0.084"></a-entity>
  <a-entity id="station5_D_phone_131" gltf-model="#smartphoneGLB" position="0.339 0.072 -0.037" rotation="-90.9 250.7 -1.5" scale="0.084 0.084 0.084"></a-entity>
</a-entity>

<!-- Station 5: Authority trace panel -->
<a-plane id="station5_A_authority_trace_panel"
         width="1.8" height="2.602"
         position="22.5 2 29.9"
         rotation="0 180 0"
         material="shader: flat; src: #station5_A_authority_trace_2048x2960; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
</a-plane>

<!-- Wall 2 graphic panel (text directly on wall; no backplate) -->
<a-plane id="Wall2_panel"
         width="3.6" height="2.4"
         position="17.93 1.85 3.00"
         rotation="0 -90 0"
         material="shader: standard; src: #Wall2Tex; transparent: true; opacity: 1; alphaTest: 0.01; color: #ffffff; emissive: #ffffff; emissiveMap: #Wall2Tex; emissiveIntensity: 2.2; roughness: 1; metalness: 0; side: double; depthWrite: false; depthTest: true; polygonOffset: true; polygonOffsetFactor: -4; polygonOffsetUnits: -4">
</a-plane>
<!-- Corridor LEFT wall: invisible collider + 2 one-sided skins (concrete inside, dark outside) -->
<a-box class="collider" depth="8" height="2.2" material="opacity: 0; transparent: true" position="7.44 1.1 -4" width="0.12"></a-box>
<!-- inside face (visible only from corridor) -->
<a-plane height="2.2" material="side: front" mixin="matConcreteWallsCeiling" position="7.50 1.1 -4" rotation="0 90 0" width="8"></a-plane>
<!-- outside face (visible only from main room side) -->
<a-plane height="2.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true; side: front" position="7.38 1.1 -4" rotation="0 -90 0" width="8"></a-plane>
<!-- Corridor start walls (ONLY these two corridor walls use concrete) -->
<!-- Corridor RIGHT wall: invisible collider + 2 one-sided skins (concrete inside, dark outside) -->
<a-box class="collider" depth="8" height="2.2" id="corridor_start_wall" material="opacity: 0; transparent: true" position="10.56 1.1 -4" width="0.12"></a-box>
<!-- inside face (visible only from corridor) -->
<a-plane height="2.2" material="side: front" mixin="matConcreteWallsCeiling" position="10.50 1.1 -4" rotation="0 -90 0" width="8"></a-plane>
<!-- outside face (visible only from main room side) -->
<a-plane height="2.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true; side: front" position="10.62 1.1 -4" rotation="0 90 0" width="8"></a-plane>
<a-box class="collider" depth="0.12" height="3" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="15.75 1.5 6.06" width="4.5"></a-box>
<!-- Wall 2B graphic panel (text directly on wall; no backplate) -->
<a-plane id="Wall2B_panel"
         width="3.6" height="2.4"
         position="15.75 1.85 5.99"
         rotation="0 180 0"
         material="shader: standard; src: #Wall2BTex; transparent: true; opacity: 1; alphaTest: 0.01; color: #ffffff; emissive: #ffffff; emissiveMap: #Wall2BTex; emissiveIntensity: 2.2; roughness: 1; metalness: 0; side: double; depthWrite: false; depthTest: true; polygonOffset: true; polygonOffsetFactor: -4; polygonOffsetUnits: -4">
</a-plane>
<!-- FEAR ROOM: Painting -->
<a-plane id="fear_painting"
         width="5.30" height="3.53"
         position="17.99 1.95 20"
         rotation="0 -90 0"
         material="shader: flat; src: #fear_painting_tex; transparent: true; side: double;">
</a-plane>

<a-plane id="painting_label"
         width="3.60" height="1.20"
         position="15.7 1.25 16.01"
         rotation="0 0 0"
         black-to-alpha="threshold: 22"
         material="shader: flat; src: #painting_label_tex; transparent: true; side: double;">
</a-plane>

<a-box class="collider" depth="0.12" height="3" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="15.75 1.5 15.94" width="4.5"></a-box>
<a-box class="collider" depth="10" height="3" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="17.94 1.5 11" width="0.12"></a-box>
<!-- Station 3 panels (offset from colliders to avoid z-fighting) -->
<!-- Short wall A (z ~ 6.06, facing +Z) -->
<a-plane height="2.602" id="station3_A1_panel" position="15.75 1.5 6.13" rotation="0 0 0" width="3.701" material="shader: flat; src: #station3_A1; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<!-- Long wall B (x ~ 17.94, facing -X) -->
<a-plane height="2.602" id="station3_B1_panel" position="17.87 1.5 7.11" rotation="0 -90 0" width="1.8" material="shader: flat; src: #station3_B1; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<a-plane height="2.602" id="station3_B2_panel" position="17.87 1.5 9.055" rotation="0 -90 0" width="1.8" material="shader: flat; src: #station3_B2; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<a-plane height="2.602" id="station3_B3_panel" position="17.87 1.5 11" rotation="0 -90 0" width="1.8" material="shader: flat; src: #station3_B3; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<a-plane height="2.602" id="station3_B4_panel" position="17.87 1.5 12.945" rotation="0 -90 0" width="1.8" material="shader: flat; src: #station3_B4; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<a-plane height="2.602" id="station3_B5_panel" position="17.87 1.5 14.89" rotation="0 -90 0" width="1.8" material="shader: flat; src: #station3_B5; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<!-- Short wall C (z ~ 15.94, facing -Z) -->
<a-plane height="2.602" id="station3_C1_panel" position="15.75 1.5 15.87" rotation="0 180 0" width="3.701" material="shader: flat; src: #station3_C1; transparent: true; alphaTest: 0.01; side: double; polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2"></a-plane>
<a-box class="collider" depth="6" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="5.06 1.6 25" width="0.12"></a-box>
<a-box class="collider" depth="4.7" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="12.94 1.6 23.35" width="0.12"></a-box>
<a-box class="collider" depth="0.7" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="12.94 1.6 27.65" width="0.12"></a-box>
<a-box class="collider" depth="0.12" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="9 1.6 27.94" width="8"></a-box>
<!-- Station 4: Wall Panel A1 (Promise / Policy Brief Archive) -->
<!-- Station 4: Wall Panel A1 (Promise) — mounted in framed case -->
<a-entity id="s4_wall_A1_mount" position="9 1.78 27.87" rotation="0 180 0" scale="0.9 0.9 0.9">
<!-- Backplate (off-white panel substrate) -->
<a-box depth="0.06" height="2.67" material="color: #e8e5df; roughness: 0.95; metalness: 0.0;" position="0 0 -0.03" width="3.74"></a-box>
<!-- Slim frame rails -->
<a-box depth="0.04" height="0.06" material="color: #1a1a1a; roughness: 0.6; metalness: 0.2;" position="0 1.315 -0.01" width="3.80"></a-box>
<a-box depth="0.04" height="0.06" material="color: #1a1a1a; roughness: 0.6; metalness: 0.2;" position="0 -1.315 -0.01" width="3.80"></a-box>
<a-box depth="0.04" height="2.70" material="color: #1a1a1a; roughness: 0.6; metalness: 0.2;" position="-1.90 0 -0.01" width="0.06"></a-box>
<a-box depth="0.04" height="2.70" material="color: #1a1a1a; roughness: 0.6; metalness: 0.2;" position="1.90 0 -0.01" width="0.06"></a-box>
<!-- The graphic plate -->
<a-plane height="2.53" id="s4_wall_A1_promise_panel" material="shader: flat; src: #s4_wall_A1_promise; color: #b8b8b8; transparent: false; side: front;" position="0 0 0.002" rotation="0 0 0" width="3.6">
</a-plane>
<!-- Protective acrylic (very subtle) -->
<a-plane height="2.59" material="shader: standard; transparent: true; opacity: 0.008; roughness: 0.95; metalness: 0.0; side: front; depthWrite: false;" position="0 0 0.02" rotation="0 0 0" width="3.66"></a-plane>
</a-entity>
<!-- Station 4 wall panel A2 (Enrolment) — framed case on right interior wall -->
<a-entity id="s4_wall_A2_mount" position="12.86 1.55 23.85" rotation="0 -90 0">
<!-- backplate -->
<a-box depth="0.03" height="1.35" material="color:#e8e8e2; roughness:0.95; metalness:0.0;" position="0 0 0" width="1.95"></a-box>
<!-- image -->
<a-plane height="1.28" material="shader: flat; src: #s4_wall_A2_enrolment; color: #b0b0b0; side: double;" position="0 0 0.016" width="1.88"></a-plane>
<!-- frame rails -->
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 0.695 0.02" width="1.99"></a-box>
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 -0.695 0.02" width="1.99"></a-box>
<a-box depth="0.04" height="1.39" material="color:#111; roughness:0.7; metalness:0.2;" position="-0.975 0 0.02" width="0.04"></a-box>
<a-box depth="0.04" height="1.39" material="color:#111; roughness:0.7; metalness:0.2;" position="0.975 0 0.02" width="0.04"></a-box>
<!-- acrylic cover (barely visible) -->
<a-box depth="0.01" height="1.30" material="color:#ffffff; transparent:true; opacity:0.008; roughness:0.95; metalness:0.0; side:double; depthWrite:false;" position="0 0 0.032" width="1.90"></a-box>
<!-- Station 4 wall panel A6 (Cost transfer) — framed case on back wall, right of A1 -->
</a-entity>
<!-- Station 4 wall panel A3 (Completion/Dropout) — framed case on left interior wall (mirrored) -->
<a-entity id="s4_wall_A3_mount" position="5.14 1.55 23.85" rotation="0 90 0">
<!-- backplate -->
<a-box depth="0.03" height="1.35" material="color:#e8e8e2; roughness:0.95; metalness:0.0;" position="0 0 0" width="1.95"></a-box>
<!-- image -->
<a-plane height="1.28" material="shader: flat; src: #s4_wall_A3_completion; color: #b0b0b0; side: double;" position="0 0 0.016" width="1.88"></a-plane>
<!-- frame rails -->
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 0.695 0.02" width="1.99"></a-box>
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 -0.695 0.02" width="1.99"></a-box>
<a-box depth="0.04" height="1.39" material="color:#111; roughness:0.7; metalness:0.2;" position="-0.975 0 0.02" width="0.04"></a-box>
<a-box depth="0.04" height="1.39" material="color:#111; roughness:0.7; metalness:0.2;" position="0.975 0 0.02" width="0.04"></a-box>
<!-- acrylic cover (barely visible) -->
<a-box depth="0.01" height="1.30" material="color:#ffffff; transparent:true; opacity:0.008; roughness:0.95; metalness:0.0; side:double; depthWrite:false;" position="0 0 0.032" width="1.90"></a-box>
</a-entity>
<!-- Station 4 wall panel A4 (Time mismatch) — framed case on left interior wall, deeper in bay -->
<a-entity id="s4_wall_A4_mount" position="5.14 1.70 26.40" rotation="0 90 0">
<a-entity id="s4_wall_A4_content" position="0.077 0 0" scale="1.12 1.12 1">
<!-- backplate (portrait) -->
<a-box depth="0.03" height="1.95" material="color:#e8e8e2; roughness:0.95; metalness:0.0;" position="0 0 0" width="1.35"></a-box>
<!-- image (portrait) -->
<a-plane height="1.88" material="shader: flat; src: #s4_wall_A4_time_mismatch; color: #b0b0b0; side: double;" position="0 0 0.016" width="1.28"></a-plane>
<!-- frame rails -->
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 1.005 0.02" width="1.39"></a-box>
<a-box depth="0.04" height="0.04" material="color:#111; roughness:0.7; metalness:0.2;" position="0 -1.005 0.02" width="1.39"></a-box>
<a-box depth="0.04" height="2.01" material="color:#111; roughness:0.7; metalness:0.2;" position="-0.675 0 0.02" width="0.04"></a-box>
<a-box depth="0.04" height="2.01" material="color:#111; roughness:0.7; metalness:0.2;" position="0.675 0 0.02" width="0.04"></a-box>
<!-- acrylic cover (barely visible) -->
<a-box depth="0.01" height="1.90" material="color:#ffffff; transparent:true; opacity:0.008; roughness:0.95; metalness:0.0; side:double; depthWrite:false;" position="0 0 0.032" width="1.30"></a-box>
</a-entity>
</a-entity>
<!-- Station 4 wall panel A5 + A6 (stacked) — on right interior wall (visitor view) -->
<a-entity id="s4_wall_A5A6_stack" position="7.000 1.550 21.010" rotation=" 0 0 0">
<!-- A5 (Earnings recovery) — upper -->
<a-entity id="s4_wall_A5_mount" position="-0.116 0.799 0" rotation="0 0 0" scale="0.759 0.759 1">
<a-plane height="1.19" id="s4_wall_A5_backplate" material="shader: standard; color: #e8e6e2; roughness: 0.95; metalness: 0.0; side: double;" position="0 0 0" width="1.65"></a-plane>
<a-plane height="1.09" id="s4_wall_A5_panel" material="shader: flat; src: #s4_wall_A5_earnings_recovery; side: double; color: #cfcfcf;" position="0 0 0.008" width="1.55"></a-plane>
<!-- slim frame -->
<a-box depth="0.02" height="0.03" id="s4_wall_A5_frame_top" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0 0.605 0.012" width="1.67"></a-box>
<a-box depth="0.02" height="0.03" id="s4_wall_A5_frame_bottom" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0 -0.605 0.012" width="1.67"></a-box>
<a-box depth="0.02" height="1.21" id="s4_wall_A5_frame_left" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="-0.835 0 0.012" width="0.03"></a-box>
<a-box depth="0.02" height="1.21" id="s4_wall_A5_frame_right" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0.835 0 0.012" width="0.03"></a-box>
<!-- acrylic (barely visible, like your table glass) -->
<a-plane height="1.15" id="s4_wall_A5_acrylic" material="shader: standard; color: #ffffff; transparent: true; opacity: 0.008; roughness: 0.95; metalness: 0.0; side: double; depthWrite: false;" position="0 0 0.020" width="1.61"></a-plane>
</a-entity>
<!-- A6 (Cost transfer) — lower -->
<a-entity id="s4_wall_A6_mount" position="-0.116 -0.338 0" rotation="0 0 0" scale="0.759 0.759 1">
<a-plane height="1.19" id="s4_wall_A6_backplate" material="shader: standard; color: #e8e6e2; roughness: 0.95; metalness: 0.0; side: double;" position="0 0 0" width="1.65"></a-plane>
<a-plane height="1.09" id="s4_wall_A6_panel" material="shader: flat; src: #s4_wall_A6_cost_transfer; side: double; color: #cfcfcf;" position="0 0 0.008" width="1.55"></a-plane>
<a-box depth="0.02" height="0.03" id="s4_wall_A6_frame_top" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0 0.605 0.012" width="1.67"></a-box>
<a-box depth="0.02" height="0.03" id="s4_wall_A6_frame_bottom" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0 -0.605 0.012" width="1.67"></a-box>
<a-box depth="0.02" height="1.21" id="s4_wall_A6_frame_left" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="-0.835 0 0.012" width="0.03"></a-box>
<a-box depth="0.02" height="1.21" id="s4_wall_A6_frame_right" material="shader: standard; color: #111111; roughness: 0.9; metalness: 0.1;" position="0.835 0 0.012" width="0.03"></a-box>
<a-plane height="1.15" id="s4_wall_A6_acrylic" material="shader: standard; color: #ffffff; transparent: true; opacity: 0.008; roughness: 0.95; metalness: 0.0; side: double; depthWrite: false;" position="0 0 0.020" width="1.61"></a-plane>
</a-entity>
</a-entity>
<!-- Station 4: DATASET MONOLITH (futuristic "data center" with trapped mercurial storage) -->
<a-entity id="station4_datacenter" position="9 1.60 21.51" rotation="0 0 0">
<!-- Local micro-lights (confined so they don't splash the walls) -->
<a-entity id="s4_dc_lights">
<a-entity id="s4_dc_key" light="type: spot; color: #ffffff; intensity: 10; angle: 32; penumbra: 0.78; distance: 6.0; decay: 2; castShadow: false; target: #s4_dc_mercury_stack" position="1.6 1.85 3.0"></a-entity>
<a-entity id="s4_dc_rim1" light="type: point; color: #ffffff; intensity: 10; distance: 1.45; decay: 2" position="0.14 0.95 0.38"></a-entity>
<a-entity id="s4_dc_rim2" light="type: point; color: #ffffff; intensity: 7; distance: 1.35; decay: 2" position="-0.18 -0.55 -0.22"></a-entity>
</a-entity>
<!-- Frame / shell (leaves front open for an inspection window) -->
<a-box depth="0.02" height="3.20" material="shader: standard; color:#070707; roughness:0.58; metalness:0.62" position="0 0 -0.49" width="1.10"></a-box>
<a-box depth="1.00" height="3.20" material="shader: standard; color:#060606; roughness:0.62; metalness:0.58" position="-0.525 0 0" width="0.05"></a-box>
<a-box depth="1.00" height="3.20" material="shader: standard; color:#060606; roughness:0.62; metalness:0.58" position="0.525 0 0" width="0.05"></a-box>
<a-box depth="1.00" height="0.05" material="shader: standard; color:#050505; roughness:0.64; metalness:0.55" position="0 1.575 0" width="1.10"></a-box>
<a-box depth="1.00" height="0.05" material="shader: standard; color:#050505; roughness:0.64; metalness:0.55" position="0 -1.575 0" width="1.10"></a-box>
<!-- Subtle inner ribs (datacenter feel) -->
<a-box depth="0.92" height="3.00" material="shader: standard; color:#0a0a0a; roughness:0.78; metalness:0.25; transparent:true; opacity:0.55" position="-0.20 0 0" width="0.02"></a-box>
<a-box depth="0.92" height="3.00" material="shader: standard; color:#0a0a0a; roughness:0.78; metalness:0.25; transparent:true; opacity:0.55" position="0.20 0 0" width="0.02"></a-box>
<!-- Inspection glass (not "fully glass" — just a window) -->
<a-box depth="0.012" height="3.08" id="s4_dc_glass" material="shader: standard; color:#9aa2ad; transparent:true; opacity:0.06; roughness:0.04; metalness:0.0; depthWrite:false; side:double" position="0 0 0.49" width="1.00"></a-box>
<!-- Trapped mercurial dataset core (layered liquid metal sheets, ultra-slow sinuous motion) -->
<a-entity id="s4_dc_mercury_stack" position="0 0 0">
<!-- outer mass (near-black liquid metal) -->
<a-box depth="0.90" height="2.96" id="s4_dc_mercury_outer" mercury-liquid="normalSize:128; updateMS:260; normalStrength:3.2; normalRepeatX:1.4; normalRepeatY:2.6; metalness:1.0; roughness:0.04; envIntensity:0.92; opacity:1.0; clearcoat:1.0; clearcoatRoughness:0.06; emissiveIntensity:0.010;" position="0 0 0" width="0.96"></a-box>
<!-- inner sheet (adds depth / “matter”) -->
<a-box depth="0.16" height="2.88" id="s4_dc_mercury_layer1" mercury-liquid="normalSize:128; updateMS:140; normalStrength:2.6; normalRepeatX:1.8; normalRepeatY:3.0; metalness:1.0; roughness:0.08; envIntensity:0.85; opacity:0.34; clearcoat:1.0; clearcoatRoughness:0.10; emissiveIntensity:0.008; flowScale:0.28; flowWobble:0.55; flowRotate:0.28;" position="0 0 0.02" rotation="0 8 0" width="0.92"></a-box>
</a-entity>
<!-- Entry port (lights up when impulses hit) -->
<a-circle id="s4_dc_port" material="shader: flat; color:#ffffff; transparent:true; opacity:0.0; side:double" position="0 1.18 0.496" radius="0.055" rotation="0 0 0"></a-circle>
<!-- Collider (keeps interaction consistent with previous placeholder volume) -->
<a-box class="collider" depth="1.00" height="3.20" material="color: #000000; transparent: true; opacity: 0" position="0 0 0" visible="false" width="1.10"></a-box>
</a-entity>
<!-- Station 4: wall text / gallery description (ENTRANCE wall, no backplate) -->
<!-- Placed on the short entrance-side wall segment indicated in the floorplan arrow. -->
<a-plane height="2.44" id="s4_station4_label" material="shader: flat; src: #s4_station_text; transparent: true; opacity: 1; side: front; depthTest: true; depthWrite: true;" position="11.02 1.55 19.7" rotation="0 90 0" sharp-alpha="" width="1.08">
</a-plane>
<!-- Station 04 carpet (PBR fabric, confined to Station 4 bay) -->
<a-plane height="6.90" id="station4_carpet" material="shader: standard;
              color: #070707;
              src: #carpet_base;
              normalMap: #carpet_normal;
              roughnessMap: #carpet_rough;
              metalness: 0.0;
              roughness: 1.0;" pbr-carpet="repeatX: 5.0; repeatY: 4.5; anisotropy: 8" position="9 0.012 24.45" rotation="-90 0 0" shadow="receive: true" width="7.78">
</a-plane>
<a-box class="collider" depth="1.0" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="8.34 1.6 21.5" width="0.12"></a-box>
<a-box class="collider" depth="1.0" height="3.2" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="9.66 1.6 21.5" width="0.12"></a-box>
<a-box class="collider" depth="3" height="4" material="color: #111; roughness: 0.7; metalness: 0.2; receiveShadow: true" position="7 2 19.5" width="8"></a-box>
<!-- Station 4: museum-grade evidence table (base + glass vitrine) -->
<a-entity id="station4_table" position="9 0 25" rotation="0 0 0">
<!-- Collider (invisible) -->
<a-box class="collider" depth="0.99" height="1.25" id="station4_table_collider" material="color: #000000; transparent: true; opacity: 0; depthWrite: false" position="0 0.625 0" visible="false" width="1.94">
</a-box>
<!-- TABLE BASE (matte charcoal metal) -->
<a-entity id="station4_table_base">
<!-- Main top deck (overall footprint: 1.90 x 0.95; top surface height: 0.82) -->
<a-box depth="0.95" height="0.04" id="station4_table_deck" material="shader: standard; color: #050505; roughness: 0.88; metalness: 0.18; receiveShadow: true" position="0 0.80 0" width="1.90">
</a-box>
<!-- Under-deck body / apron -->
<a-box depth="0.89" height="0.09" id="station4_table_apron" material="shader: standard; color: #060606; roughness: 0.90; metalness: 0.16; receiveShadow: true" position="0 0.735 0" width="1.84">
</a-box>
<!-- Stepped bevel edge (2 tiers of perimeter strips) -->
<!-- Tier 1 -->
<a-box depth="0.035" height="0.012" material="shader: standard; color: #070707; roughness: 0.92; metalness: 0.14" position="0 0.776 0.4575" width="1.90"></a-box>
<a-box depth="0.035" height="0.012" material="shader: standard; color: #070707; roughness: 0.92; metalness: 0.14" position="0 0.776 -0.4575" width="1.90"></a-box>
<a-box depth="0.88" height="0.012" material="shader: standard; color: #070707; roughness: 0.92; metalness: 0.14" position="-0.9325 0.776 0" width="0.035"></a-box>
<a-box depth="0.88" height="0.012" material="shader: standard; color: #070707; roughness: 0.92; metalness: 0.14" position="0.9325 0.776 0" width="0.035"></a-box>
<!-- Tier 2 (slightly inset) -->
<a-box depth="0.032" height="0.012" material="shader: standard; color: #080808; roughness: 0.94; metalness: 0.12" position="0 0.760 0.427" width="1.84"></a-box>
<a-box depth="0.032" height="0.012" material="shader: standard; color: #080808; roughness: 0.94; metalness: 0.12" position="0 0.760 -0.427" width="1.84"></a-box>
<a-box depth="0.826" height="0.012" material="shader: standard; color: #080808; roughness: 0.94; metalness: 0.12" position="-0.904 0.760 0" width="0.032"></a-box>
<a-box depth="0.826" height="0.012" material="shader: standard; color: #080808; roughness: 0.94; metalness: 0.12" position="0.904 0.760 0" width="0.032"></a-box>
<!-- Sled legs (2) -->
<a-entity id="station4_table_sled_left">
<a-box depth="0.85" height="0.05" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="-0.82 0.025 0" width="0.05"></a-box>
<a-box depth="0.05" height="0.70" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="-0.82 0.35 0.36" width="0.05"></a-box>
<a-box depth="0.05" height="0.70" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="-0.82 0.35 -0.36" width="0.05"></a-box>
<a-box depth="0.85" height="0.05" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="-0.82 0.70 0" width="0.05"></a-box>
</a-entity>
<a-entity id="station4_table_sled_right">
<a-box depth="0.85" height="0.05" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="0.82 0.025 0" width="0.05"></a-box>
<a-box depth="0.05" height="0.70" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="0.82 0.35 0.36" width="0.05"></a-box>
<a-box depth="0.05" height="0.70" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="0.82 0.35 -0.36" width="0.05"></a-box>
<a-box depth="0.85" height="0.05" material="shader: standard; color: #050505; roughness: 0.86; metalness: 0.22; receiveShadow: true" position="0.82 0.70 0" width="0.05"></a-box>
</a-entity></a-entity>
<!-- GLASS VITRINE (thin panes + top rail) -->
<a-entity id="station4_table_vitrine">
<!-- Glass material tuned: transparent, low metalness, high roughness, depthWrite false -->
<a-box depth="0.006" height="0.34" id="station4_glass_front" material="shader: standard; color: #e8eef5; transparent: true; opacity: 0.06; metalness: 0.0; roughness: 0.22; depthWrite: false; side: double" position="0 0.993 0.395" width="1.72">
</a-box>
<a-box depth="0.006" height="0.34" id="station4_glass_back" material="shader: standard; color: #e8eef5; transparent: true; opacity: 0.06; metalness: 0.0; roughness: 0.22; depthWrite: false; side: double" position="0 0.993 -0.395" width="1.72">
</a-box>
<a-box depth="0.78" height="0.34" id="station4_glass_left" material="shader: standard; color: #e8eef5; transparent: true; opacity: 0.06; metalness: 0.0; roughness: 0.22; depthWrite: false; side: double" position="-0.865 0.993 0" width="0.006">
</a-box>
<a-box depth="0.78" height="0.34" id="station4_glass_right" material="shader: standard; color: #e8eef5; transparent: true; opacity: 0.06; metalness: 0.0; roughness: 0.22; depthWrite: false; side: double" position="0.865 0.993 0" width="0.006">
</a-box>
<a-box depth="0.78" height="0.006" id="station4_glass_top" material="shader: standard; color: #eef2f8; transparent: true; opacity: 0.05; metalness: 0.0; roughness: 0.28; depthWrite: false; side: double" position="0 1.168 0" width="1.72">
</a-box>
<!-- Subtle bottom frame + corner posts (helps read the glass edges under haze) -->
<a-box depth="0.012" height="0.010" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="0 0.823 0.401" width="1.748"></a-box>
<a-box depth="0.012" height="0.010" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="0 0.823 -0.401" width="1.748"></a-box>
<a-box depth="0.804" height="0.010" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="-0.871 0.823 0" width="0.012"></a-box>
<a-box depth="0.804" height="0.010" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="0.871 0.823 0" width="0.012"></a-box>
<a-box depth="0.012" height="0.34" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="-0.871 0.993 0.401" width="0.012"></a-box>
<a-box depth="0.012" height="0.34" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="0.871 0.993 0.401" width="0.012"></a-box>
<a-box depth="0.012" height="0.34" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="-0.871 0.993 -0.401" width="0.012"></a-box>
<a-box depth="0.012" height="0.34" material="shader: standard; color: #0a0a0a; roughness: 0.35; metalness: 0.75" position="0.871 0.993 -0.401" width="0.012"></a-box>
<!-- Slim metal rail/frame around the top edge (slightly offset to avoid z-fighting) -->
<a-box depth="0.012" height="0.008" material="shader: standard; color: #0a0a0a; roughness: 0.42; metalness: 0.62" position="0 1.173 0.401" width="1.748"></a-box>
<a-box depth="0.012" height="0.008" material="shader: standard; color: #0a0a0a; roughness: 0.42; metalness: 0.62" position="0 1.173 -0.401" width="1.748"></a-box>
<a-box depth="0.804" height="0.008" material="shader: standard; color: #0a0a0a; roughness: 0.42; metalness: 0.62" position="-0.871 1.173 0" width="0.012"></a-box>
<a-box depth="0.804" height="0.008" material="shader: standard; color: #0a0a0a; roughness: 0.42; metalness: 0.62" position="0.871 1.173 0" width="0.012"></a-box>
</a-entity>
<!-- Station 4: EVIDENCE SET (tidy, scaled to fit vitrine) -->
<!-- All objects sit on the tabletop (top surface y≈0.82). Keep within vitrine interior (≈1.70w × 0.76d usable). -->
<a-entity id="station4_table_contents">
<!-- LEFT BLOCK: three folders, aligned stack (clear "folder" read) -->
<a-entity id="s4_folders" position="-0.44 0 -0.02" rotation="0 0 0">
<!-- Folder carrier (thin box) + a small spine lip on the left -->
<!-- Initiative (bottom) -->
<a-entity position="0 0 0">
<a-box depth="0.46" height="0.020" material="shader: standard; color: #0e0e0e; roughness: 0.96; metalness: 0.02" position="0 0.835 0" width="0.62"></a-box>
<a-box depth="0.46" height="0.026" material="shader: standard; color: #070707; roughness: 0.92; metalness: 0.06" position="-0.305 0.838 0" width="0.010"></a-box>
<a-plane height="0.465" material="shader: standard; src: #s4_folder_initiative; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.96; metalness: 0.0" position="0 0.8465 0" rotation="-90 0 0" width="0.62"></a-plane>
</a-entity>
<!-- Mid-term (middle) -->
<a-entity position="0.03 0.004 -0.02">
<a-box depth="0.46" height="0.019" material="shader: standard; color: #0b0b0b; roughness: 0.96; metalness: 0.02" position="0 0.835 0" width="0.62"></a-box>
<a-box depth="0.46" height="0.025" material="shader: standard; color: #060606; roughness: 0.92; metalness: 0.06" position="-0.305 0.838 0" width="0.010"></a-box>
<a-plane height="0.465" material="shader: standard; src: #s4_folder_midterm; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.96; metalness: 0.0" position="0 0.8460 0" rotation="-90 0 0" width="0.62"></a-plane>
</a-entity>
<!-- Final (top) -->
<a-entity position="0.06 0.008 -0.04">
<a-box depth="0.46" height="0.018" material="shader: standard; color: #070707; roughness: 0.96; metalness: 0.02" position="0 0.835 0" width="0.62"></a-box>
<a-box depth="0.46" height="0.024" material="shader: standard; color: #050505; roughness: 0.92; metalness: 0.06" position="-0.305 0.838 0" width="0.010"></a-box>
<a-plane height="0.465" material="shader: standard; src: #s4_folder_final; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.96; metalness: 0.0" position="0 0.8455 0" rotation="-90 0 0" width="0.62"></a-plane>
</a-entity>
</a-entity>
<!-- RIGHT BLOCK: two packets, squared stack -->
<a-entity id="s4_packets" position="0.42 0 -0.04" rotation="0 0 0">
<!-- Policy brief (bottom) -->
<a-entity position="0 0 0">
<a-box depth="0.44" height="0.016" material="shader: standard; color: #d9d9d9; roughness: 0.98; metalness: 0.0" position="0 0.833 0" width="0.60"></a-box>
<a-plane height="0.435" material="shader: standard; src: #s4_packet_policybrief_2026; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.98; metalness: 0.0" position="0 0.842 0" rotation="-90 0 0" width="0.58"></a-plane>
</a-entity>
<!-- Outcome review (top) -->
<a-entity position="-0.03 0.004 0.04">
<a-box depth="0.44" height="0.018" material="shader: standard; color: #cfcfcf; roughness: 0.98; metalness: 0.0" position="0 0.833 0" width="0.60"></a-box>
<a-plane height="0.435" material="shader: standard; src: #s4_packet_outcome_review_2034; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.98; metalness: 0.0" position="0 0.843 0" rotation="-90 0 0" width="0.58"></a-plane>
</a-entity>
</a-entity>
<!-- FRONT ROW: three extracts, tidy grid (no overlap beyond vitrine) -->
<a-entity id="s4_extracts" position="0 0 0.18" rotation="0 0 0">
<a-entity position="-0.36 0 0">
<a-box depth="0.33" height="0.003" material="shader: standard; color: #e0e0e0; roughness: 0.99; metalness: 0.0" position="0 0.826 0" width="0.44"></a-box>
<a-plane height="0.33" material="shader: standard; src: #s4_extract_redacted_01; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.99; metalness: 0.0" position="0 0.828 0" rotation="-90 0 0" width="0.44"></a-plane>
</a-entity>
<a-entity position="0.00 0.002 0">
<a-box depth="0.33" height="0.003" material="shader: standard; color: #e0e0e0; roughness: 0.99; metalness: 0.0" position="0 0.826 0" width="0.44"></a-box>
<a-plane height="0.33" material="shader: standard; src: #s4_extract_redacted_02; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.99; metalness: 0.0" position="0 0.829 0" rotation="-90 0 0" width="0.44"></a-plane>
</a-entity>
<a-entity position="0.36 0.004 0">
<a-box depth="0.33" height="0.003" material="shader: standard; color: #e0e0e0; roughness: 0.99; metalness: 0.0" position="0 0.826 0" width="0.44"></a-box>
<a-plane height="0.33" material="shader: standard; src: #s4_extract_redacted_03; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.99; metalness: 0.0" position="0 0.830 0" rotation="-90 0 0" width="0.44"></a-plane>
</a-entity>
</a-entity>
<!-- BACK CENTER: errata sheet, tucked behind packets -->
<a-entity id="s4_errata" position="0.06 0 -0.20" rotation="0 0 0">
<a-box depth="0.38" height="0.004" material="shader: standard; color: #e3e3e3; roughness: 0.99; metalness: 0.0" position="0 0.826 0" width="0.52"></a-box>
<a-plane height="0.39" material="shader: standard; src: #s4_sheet_errata; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.99; metalness: 0.0" position="0 0.829 0" rotation="-90 0 0" width="0.52"></a-plane>
</a-entity>
<!-- BACK RIGHT: museum label card, aligned -->
<a-entity id="s4_label" position="0.46 0 -0.24" rotation="0 0 0">
<a-box depth="0.28" height="0.008" material="shader: standard; color: #ded6c9; roughness: 0.98; metalness: 0.0" position="0 0.826 0" width="0.42"></a-box>
<a-plane height="0.28" material="shader: standard; src: #s4_label_card; transparent: false; alphaTest: 0.12; side: double; anisotropy: 16; minFilter: linearMipmapLinearFilter; magFilter: linearFilter; roughness: 0.98; metalness: 0.0" position="0 0.831 0" rotation="-90 0 0" width="0.42"></a-plane>
</a-entity>
</a-entity>
</a-entity>
<!-- Station 4: test spotlights above evidence table (fixtures + visible light cones) -->
<!-- Station 4: ceiling-integrated spotlight above evidence table -->
<a-entity id="station4_table_spotlights" position="9 0 25" rotation="0 0 0">
<!-- Target aimed at table top center -->
<a-entity id="station4_table_light_target" position="0 0.90 0"></a-entity>
<!-- Beam end reference on the floor (keeps cone size consistent with the visible floor pool) -->
<a-entity id="station4_beam_end" position="0 0.02 0"></a-entity>
<!-- Recessed ceiling downlight (small visible trim; no hanging fixture) -->
<a-entity id="station4_ceiling_downlight" position="0 5.999 0" rotation="-90 0 0">
<!-- trim ring -->
<a-ring material="shader: standard; color: #0b0b0b; roughness: 0.55; metalness: 0.35; side: double" radius-inner="0.075" radius-outer="0.105">
</a-ring>
<!-- subtle emitter disc -->
<a-circle material="shader: standard; color: #ffffff; emissive: #ffffff; emissiveIntensity: 0.85; roughness: 1.0; metalness: 0.0; transparent: true; opacity: 0.9; side: double" radius="0.060">
</a-circle>
</a-entity>
<!-- Actual spotlight source (strong enough for physicallyCorrectLights) -->
<a-entity id="station4_spotlight_1" light="type: spot; color: #ffffff; intensity: 35; angle: 23; penumbra: 0.7; distance: 14; decay: 2; castShadow: false; target: #station4_table_light_target" position="0 5.95 0">
</a-entity>
<!-- Visible volumetric beam (fake) + localized haze for cinematic 'smoke machine' look -->
<a-entity aim-down-axis="target: #station4_beam_end" id="station4_spot_beam" light-beam="opacity: 0.060; color: #ffffff; driftU: 0.013; driftV: 0.075; layers: 1; edgeSoftness: 0.28; floorSoftness: 1.70; floorOpacity: 0.34" match-spotlight-cone="light: #station4_spotlight_1; target: #station4_beam_end; radiusMult: 1.0; lengthMult: 1.0" position="0 5.95 0">
</a-entity>
</a-entity>


<!-- Station 4: additional ceiling spotlight (fixture + actual light; NO volumetric beam/fog) -->
<a-entity id="station4_table_spotlights_2" position="21.5 0 27" rotation="0 0 0">
  <!-- Target aimed at floor/table height (matches Station 4) -->
  <a-entity id="station4_table_light_target_2" position="0 0.90 0"></a-entity>

  <!-- Recessed ceiling downlight (small visible trim; no hanging fixture) -->
  <a-entity id="station4_ceiling_downlight_2" position="0 5.999 0" rotation="-90 0 0">
    <!-- trim ring -->
    <a-ring material="shader: standard; color: #0b0b0b; roughness: 0.55; metalness: 0.35; side: double" radius-inner="0.075" radius-outer="0.105"></a-ring>
    <!-- subtle emitter disc -->
    <a-circle material="shader: standard; color: #ffffff; emissive: #ffffff; emissiveIntensity: 0.85; roughness: 1.0; metalness: 0.0; transparent: true; opacity: 0.9; side: double" radius="0.060"></a-circle>
  </a-entity>

  <!-- Actual spotlight source (matches Station 4) -->
  <a-entity id="station4_spotlight_2" light="type: spot; color: #ffffff; intensity: 55; angle: 23; penumbra: 0.7; distance: 14; decay: 2; castShadow: false; target: #station4_table_light_target_2" position="0 5.9 0"></a-entity>
</a-entity>

<a-entity id="station4_table_spotlights_3" position="21.5 0 22" rotation="0 0 0">
  <!-- Target aimed at floor/table height (matches Station 4) -->
  <a-entity id="station4_table_light_target_3" position="0 0.90 0"></a-entity>

  <!-- Recessed ceiling downlight (small visible trim; no hanging fixture) -->
  <a-entity id="station4_ceiling_downlight_3" position="0 5.999 0" rotation="-90 0 0">
    <!-- trim ring -->
    <a-ring material="shader: standard; color: #0b0b0b; roughness: 0.55; metalness: 0.35; side: double" radius-inner="0.075" radius-outer="0.105"></a-ring>
    <!-- subtle emitter disc -->
    <a-circle material="shader: standard; color: #ffffff; emissive: #ffffff; emissiveIntensity: 0.85; roughness: 1.0; metalness: 0.0; transparent: true; opacity: 0.9; side: double" radius="0.060"></a-circle>
  </a-entity>

  <!-- Actual spotlight source (matches Station 4) -->
  <a-entity id="station4_spotlight_3" light="type: spot; color: #ffffff; intensity: 55; angle: 23; penumbra: 0.7; distance: 14; decay: 2; castShadow: false; target: #station4_table_light_target_3" position="0 5.9 0"></a-entity>
</a-entity>
<a-entity id="station2" position="8.5 0 10.5" rotation="0 0 0" scale="0.40 0.40 0.40">
<a-box depth="1.25" height="14.80" id="core" material="color:#050505; roughness:0.2; metalness:0.8; castShadow: true; receiveShadow: true" position="0 7.50 0" width="1.45">
</a-box>
<a-entity monolith-inscriptions="target:#core"></a-entity>
<a-entity fear-network=""></a-entity>
</a-entity>
<a-box class="collider station2-collider" depth="3.10" height="0.60" material="color:#000000; transparent:true; opacity:0" position="8.5 0.20 10.5" width="3.10">
</a-box>
<a-box class="collider station2-collider" depth="0.65" height="6.20" material="color:#000000; transparent:true; opacity:0" position="8.5 3.00 10.5" width="0.65">
</a-box>
<a-entity id="rig" position="9 0 -7.5" rotation="0 180 0" rig-walk="speed: 2.6; radius: 0.28" elevator-user-guide="target: #industrial_elevator_1; showDistance: 6">
<a-entity camera="fov: 60; near: 0.05; far: 1000; zoom: 1.08" id="playerCam" initial-yaw="yaw: 0" look-controls="pointerLockEnabled: true" pitch-clamp="min: -80; max: 80" position="0 1.6 0" rotation="0 0 0">
<a-entity id="headLamp" light="type: spot; color: #fffef0; intensity: 0.8; angle: 50; penumbra: 0.5; distance: 10; decay: 1.5; castShadow: true" position="0 0 0"></a-entity>
<a-entity cursor="rayOrigin: mouse"></a-entity>
</a-entity>
</a-entity>
<script>
      (function () {
        const DEG2RAD = Math.PI / 180;
        const EPS = 0.001;

        
        AFRAME.registerComponent('screen-surface', {
          /**
           * Drives the projection surface as a self-lit PBR screen,
           * with an optional lightweight "grade" (contrast/brightness/saturation)
           * using a canvas + ctx.filter (GPU-accelerated in modern browsers).
           */
          schema: {
            src: { type: 'asset', default: '' },
            maxLuma: { type: 'number', default: 1.0 },      // 0..1 emissive white point
            gain: { type: 'number', default: 2.0 },         // emissiveIntensity boost
            contrast: { type: 'number', default: 1.0 },     // 1 = unchanged
            brightness: { type: 'number', default: 1.0 },   // 1 = unchanged
            saturation: { type: 'number', default: 1.0 }    // 1 = unchanged
          },

          init: function () {
            this._videoEl = null;
            this._canvas = null;
            this._ctx = null;
            this._tex = null;
            this._raf = 0;
            this._lastSrcKey = '';
            this._apply();
          },

          remove: function () { this._stopLoop(); },

          update: function () { this._apply(); },

          _resolveVideo: function (src) {
            if (!src) return null;
            if (typeof src === 'string') {
              if (src[0] === '#') return document.querySelector(src);
              // URL string: not supported for grading; return null and let A-Frame handle elsewhere
              return null;
            }
            // Sometimes A-Frame resolves assets to an element.
            if (src && src.tagName) return src;
            return null;
          },

          _stopLoop: function () {
            if (this._raf) cancelAnimationFrame(this._raf);
            this._raf = 0;
          },

          _ensureCanvas: function (w, h) {
            if (!this._canvas) {
              this._canvas = document.createElement('canvas');
              this._ctx = this._canvas.getContext('2d', { alpha: false, desynchronized: true });
            }
            const cw = Math.max(2, w | 0), ch = Math.max(2, h | 0);
            if (this._canvas.width !== cw || this._canvas.height !== ch) {
              this._canvas.width = cw;
              this._canvas.height = ch;
            }
            if (!this._tex) {
              this._tex = new THREE.CanvasTexture(this._canvas);
              this._tex.minFilter = THREE.LinearFilter;
              this._tex.magFilter = THREE.LinearFilter;
              this._tex.generateMipmaps = false;
            }
          },

          _apply: function () {
            const mesh = this.el.getObject3D('mesh');
            if (!mesh) {
              this.el.addEventListener('object3dset', () => this._apply(), { once: true });
              return;
            }

            const maxL = Math.max(0.0, Math.min(1.0, this.data.maxLuma));
            const gain = Math.max(0.0, this.data.gain);

            const v = this._resolveVideo(this.data.src);
            this._videoEl = v;

            // Base material (self-lit), no src here—map gets injected manually.
            this.el.setAttribute('material', {
              shader: 'standard',
              color: '#ffffff',
              roughness: 1.0,
              metalness: 0.0,
              emissive: '#ffffff',
              emissiveIntensity: gain,
              side: 'double'
            });

            const applyToMaterial = () => {
              const m = mesh.material;
              if (!m) return;

              // Prevent tonemapping from crushing the screen.
              m.toneMapped = false;
              m.emissiveIntensity = gain;
              m.emissive = new THREE.Color(maxL, maxL, maxL);

              // If we can grade via canvas, use it; otherwise fall back to A-Frame's video map.
              if (this._tex) {
                m.map = this._tex;
                m.emissiveMap = this._tex;
              }

              m.needsUpdate = true;
            };

            // If no video element, shut down grading loop and darken.
            if (!v) {
              this._stopLoop();
              const m = mesh.material;
              if (m) {
                m.emissiveIntensity = 0.0;
                m.needsUpdate = true;
              }
              return;
            }

            const srcKey = (v.id || v.currentSrc || v.src || 'video');
            const gradeOn = (Math.abs(this.data.contrast - 1.0) > 1e-3) ||
                            (Math.abs(this.data.brightness - 1.0) > 1e-3) ||
                            (Math.abs(this.data.saturation - 1.0) > 1e-3);

            // If grading is off, let A-Frame handle the video texture directly (cheaper).
            if (!gradeOn) {
              this._stopLoop();
              this._tex = null;
              this._canvas = null;
              this._ctx = null;

              this.el.setAttribute('material', {
                shader: 'standard',
                src: this.data.src,
                color: '#ffffff',
                roughness: 1.0,
                metalness: 0.0,
                emissive: '#ffffff',
                emissiveIntensity: gain,
                side: 'double'
              });

              // After rebuild, reapply toneMapped false + emissiveMap = map.
              const fix = () => {
                const mm = mesh.material;
                if (!mm) return;
                mm.toneMapped = false;
                if (mm.map) {
                  mm.emissiveMap = mm.map;
                  mm.emissive = new THREE.Color(maxL, maxL, maxL);
                }
                mm.emissiveIntensity = gain;
                mm.needsUpdate = true;
              };
              fix();
              setTimeout(fix, 0);
              return;
            }

            // Graded path: canvas → texture.
            const setup = () => {
              const w = v.videoWidth || 1024;
              const h = v.videoHeight || 512;
              this._ensureCanvas(w, h);

              applyToMaterial();
              setTimeout(applyToMaterial, 0);

              if (this._lastSrcKey !== srcKey) {
                this._lastSrcKey = srcKey;
              }

              this._stopLoop();

              const draw = () => {
                if (!this._ctx || !this._canvas) return;

                // ctx.filter is fast and readable; browser decides best implementation.
                const c = Math.max(0.0, this.data.contrast);
                const b = Math.max(0.0, this.data.brightness);
                const s = Math.max(0.0, this.data.saturation);
                this._ctx.filter = `contrast(${c}) brightness(${b}) saturate(${s})`;

                try {
                  this._ctx.drawImage(v, 0, 0, this._canvas.width, this._canvas.height);
                  if (this._tex) this._tex.needsUpdate = true;
                } catch (e) {
                  // If video isn't ready yet, ignore.
                }
              };

              const loop = () => {
                draw();
                this._raf = requestAnimationFrame(loop);
              };

              // Prefer per-frame callback if available.
              if (typeof v.requestVideoFrameCallback === 'function') {
                const onFrame = () => {
                  draw();
                  v.requestVideoFrameCallback(onFrame);
                };
                v.requestVideoFrameCallback(onFrame);
              } else {
                this._raf = requestAnimationFrame(loop);
              }
            };

            if (v.readyState >= 1) setup();
            else v.addEventListener('loadedmetadata', setup, { once: true });
          }
        });




AFRAME.registerComponent('positional-media-audio', {
  schema: {
    el: { type: 'selector' },
    volume: { type: 'number', default: 0.22 },
    refDistance: { type: 'number', default: 1.4 },
    maxDistance: { type: 'number', default: 22.0 },
    rolloffFactor: { type: 'number', default: 1.4 }
  },

  init: function () {
    this._mediaEl = this.data.el || null;

    this._ctx = null;
    this._panner = null;
    this._gain = null;
    this._src = null;

    this._lastPos = new THREE.Vector3();
    this._listenerPos = new THREE.Vector3();
    this._listenerFwd = new THREE.Vector3();
    this._listenerUp = new THREE.Vector3();
    this._listenerQuat = new THREE.Quaternion();

    this._ready = false;

    this._ensure = () => {
      if (this._ready) return;
      if (!this._mediaEl || !window.THREE) return;

      // Use Three.js singleton AudioContext (prevents multiple contexts + works better with policies).
      try {
        this._ctx = THREE.AudioContext.getContext();
      } catch (e) {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) return;
        this._ctx = new AudioCtx();
      }

      try {
        this._panner = this._ctx.createPanner();
        this._panner.panningModel = 'HRTF';
        this._panner.distanceModel = 'inverse';
        this._panner.refDistance = this.data.refDistance;
        this._panner.maxDistance = this.data.maxDistance;
        this._panner.rolloffFactor = this.data.rolloffFactor;

        this._gain = this._ctx.createGain();
        this._gain.gain.value = this.data.volume;

        // Important: a MediaElement can only be wrapped once.
        if (!this._mediaEl.__fearRoomMediaElementSource) {
          this._mediaEl.__fearRoomMediaElementSource = this._ctx.createMediaElementSource(this._mediaEl);
        }
        this._src = this._mediaEl.__fearRoomMediaElementSource;

        // Connect chain (avoid double-connecting if component re-inits).
        if (!this._panner.__fearRoomConnected) {
          this._src.connect(this._panner);
          this._panner.connect(this._gain);
          this._gain.connect(this._ctx.destination);
          this._panner.__fearRoomConnected = true;
        }

        this._ready = true;
      } catch (e) {
        // If something fails (policy / CORS / unsupported), leave _ready false.
        this._ready = false;
      }
    };

    // Audio graph + playback are initialized on first user gesture (required by most browsers).

    const unlock = async () => {
      // Make sure the media element is actually allowed to produce audio.
      // (Autoplay with sound is usually blocked, but inside a user gesture it's permitted.)
      try {
        if (this._mediaEl) {
          this._mediaEl.muted = false;
          this._mediaEl.volume = 1.0;
          this._mediaEl.playsInline = true;
          const p0 = this._mediaEl.play();
          if (p0 && p0.catch) p0.catch(() => {});
        }
      } catch (e) {}

      // Build/ensure the WebAudio graph AFTER we enable the element audio.
      this._ensure();

      // Resume WebAudio if needed.
      try {
        if (this._ctx && this._ctx.state === 'suspended') await this._ctx.resume();
      } catch (e) {}

      // Nudge play again in case the first attempt happened before the context resumed.
      try {
        if (this._mediaEl) {
          const p1 = this._mediaEl.play();
          if (p1 && p1.catch) p1.catch(() => {});
        }
      } catch (e) {}
    };

    // Reliable user-gesture unlock.
    window.addEventListener('pointerdown', unlock, { once: true });
    window.addEventListener('keydown', unlock, { once: true });
  },

  update: function () {
    // Live-tuneable params.
    if (this._panner) {
      this._panner.refDistance = this.data.refDistance;
      this._panner.maxDistance = this.data.maxDistance;
      this._panner.rolloffFactor = this.data.rolloffFactor;
    }
    if (this._gain) this._gain.gain.value = this.data.volume;
  },

  tick: function () {
    if (!this._ready || !this._panner) return;

    // Source position (world).
    const pos = this.el.object3D.getWorldPosition(this._lastPos);
    if (this._panner.positionX) {
      this._panner.positionX.value = pos.x;
      this._panner.positionY.value = pos.y;
      this._panner.positionZ.value = pos.z;
    } else {
      this._panner.setPosition(pos.x, pos.y, pos.z);
    }

    // Listener follows camera (world).
    const camEl = this.el.sceneEl && this.el.sceneEl.camera && this.el.sceneEl.camera.el;
    const listener = this._ctx && this._ctx.listener;
    if (!camEl || !listener) return;

    camEl.object3D.getWorldPosition(this._listenerPos);
    camEl.object3D.getWorldQuaternion(this._listenerQuat);
    this._listenerFwd.set(0, 0, -1).applyQuaternion(this._listenerQuat).normalize();
    this._listenerUp.set(0, 1, 0).applyQuaternion(this._listenerQuat).normalize();

    if (listener.positionX) {
      listener.positionX.value = this._listenerPos.x;
      listener.positionY.value = this._listenerPos.y;
      listener.positionZ.value = this._listenerPos.z;

      if (listener.forwardX) {
        listener.forwardX.value = this._listenerFwd.x;
        listener.forwardY.value = this._listenerFwd.y;
        listener.forwardZ.value = this._listenerFwd.z;
        listener.upX.value = this._listenerUp.x;
        listener.upY.value = this._listenerUp.y;
        listener.upZ.value = this._listenerUp.z;
      } else if (listener.setOrientation) {
        listener.setOrientation(
          this._listenerFwd.x, this._listenerFwd.y, this._listenerFwd.z,
          this._listenerUp.x, this._listenerUp.y, this._listenerUp.z
        );
      }
    } else {
      // Safari legacy.
      if (listener.setPosition) listener.setPosition(this._listenerPos.x, this._listenerPos.y, this._listenerPos.z);
      if (listener.setOrientation) {
        listener.setOrientation(
          this._listenerFwd.x, this._listenerFwd.y, this._listenerFwd.z,
          this._listenerUp.x, this._listenerUp.y, this._listenerUp.z
        );
      }
    }
  },

  syncTo: function (t) {
    // Optional: keep media time aligned (harmless when using the same <video>).
    if (!this._mediaEl) return;
    try {
      const ct = this._mediaEl.currentTime || 0;
      if (Math.abs(ct - t) > 0.25) this._mediaEl.currentTime = t;
    } catch (e) {}
  }

});


AFRAME.registerComponent('screen-always-on', {
          schema: {
            video: { type: 'selector' },
            audio: { type: 'selector' },
            spillLight: { type: 'selector' },     // spot
            spillIntensity: { type: 'number', default: 1.4 },
            spillDistance: { type: 'number', default: 10.0 },
            spillAngle: { type: 'number', default: 55.0 },
            spillPenumbra: { type: 'number', default: 0.9 },

            spillPoint: { type: 'selector' },     // soft point fill
            pointIntensity: { type: 'number', default: 0.35 },
            pointDistance: { type: 'number', default: 6.5 }
          },

          init: function () {
            this._videoEl = this.data.video || null;

            // Positional audio (separate element, synced to video time).
            this.el.setAttribute('positional-media-audio', {
              el: (this.data.audio || this.data.video),
              volume: 0.68,
              refDistance: 1.4,
              maxDistance: 22.0,
              rolloffFactor: 1.4
            });

            this._setSpill(true);
            this._startVideo();
          },

          tick: function () {
            const aud = this.el.components['positional-media-audio'];
            if (aud && this._videoEl && !this._videoEl.paused) aud.syncTo(this._videoEl.currentTime || 0);
          },

          _setSpill: function (on) {
            const setLight = (el, patch) => {
              if (!el) return;
              const cur = el.getAttribute('light');
              if (!cur) return;
              el.setAttribute('light', Object.assign({}, cur, patch));
            };

            setLight(this.data.spillLight, {
              intensity: on ? this.data.spillIntensity : 0.0,
              distance: this.data.spillDistance,
              angle: this.data.spillAngle,
              penumbra: this.data.spillPenumbra
            });

            setLight(this.data.spillPoint, {
              intensity: on ? this.data.pointIntensity : 0.0,
              distance: this.data.pointDistance
            });
          },

          _startVideo: function () {
            if (!this._videoEl) return;
            try {
              this._videoEl.muted = true;
              this._videoEl.volume = 0.0;
              this._videoEl.loop = true;
              this._videoEl.playsInline = true;
              const p = this._videoEl.play();
              if (p && p.catch) p.catch(() => {});
            } catch (e) {}
          }
        });


        AFRAME.registerComponent('pitch-clamp', {
          schema: { min: { type: 'number', default: -80 }, max: { type: 'number', default: 80 } },
          tick: function () {
            const lc = this.el.components['look-controls'];
            if (!lc || !lc.pitchObject) return;
            const minR = this.data.min * DEG2RAD;
            const maxR = this.data.max * DEG2RAD;
            const p = lc.pitchObject.rotation.x;
            lc.pitchObject.rotation.x = Math.min(maxR, Math.max(minR, p));
          }
        });

AFRAME.registerComponent('initial-yaw', {
  schema: { yaw: { type: 'number', default: 0 } },
  init: function () {
    const targetYaw = (this.data.yaw || 0) * (Math.PI / 180);
    const el = this.el;

    const apply = () => {
      const lc = el.components && el.components['look-controls'];
      if (lc && lc.yawObject) {
        lc.yawObject.rotation.y = targetYaw;
        return true;
      }
      return false;
    };

    let tries = 0;
    const tickTry = () => {
      if (apply()) return;
      tries++;
      if (tries < 240) requestAnimationFrame(tickTry); // ~4s safety
    };

    tickTry();
    el.addEventListener('componentinitialized', (e) => {
      if (e.detail && e.detail.name === 'look-controls') { tries = 0; tickTry(); }
    });
  }
});

        AFRAME.registerComponent('rig-walk', {
          schema: { speed: { type: 'number', default: 2.4 }, radius: { type: 'number', default: 0.28 } },
          init: function () {
            this.keys = Object.create(null);
            this._colliders = [];
            this._tmpVec3 = new THREE.Vector3();
            this._lastColliderRefresh = 0;

            const MOVE_KEYS = new Set(['KeyW','KeyA','KeyS','KeyD','ArrowUp','ArrowLeft','ArrowDown','ArrowRight']);

            this._onKeyDown = (e) => {
              const t = e.target;
              if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;
              if (MOVE_KEYS.has(e.code)) e.preventDefault();
              this.keys[e.code] = true;
            };
            this._onKeyUp = (e) => {
              const t = e.target;
              if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;
              if (MOVE_KEYS.has(e.code)) e.preventDefault();
              this.keys[e.code] = false;
            };
            this._clearKeys = () => { for (const k in this.keys) this.keys[k] = false; };

            // Capture at both document + window level for maximum reliability (some embeds / focus states drop one or the other).
            this._keyOpts = { passive: false, capture: true };
            window.addEventListener('keydown', this._onKeyDown, this._keyOpts);
            window.addEventListener('keyup', this._onKeyUp, this._keyOpts);
            document.addEventListener('keydown', this._onKeyDown, this._keyOpts);
            document.addEventListener('keyup', this._onKeyUp, this._keyOpts);

            window.addEventListener('blur', this._clearKeys);
            document.addEventListener('visibilitychange', () => { if (document.hidden) this._clearKeys(); });
            document.addEventListener('pointerlockchange', () => { if (!document.pointerLockElement) this._clearKeys(); });

            const scene = this.el.sceneEl;
            if (scene.hasLoaded) this._refreshColliders();
            else scene.addEventListener('loaded', () => this._refreshColliders());
          },
          remove: function () {
            // Clean up listeners (prevents double-handling if scene hot-reloads).
            try {
              const opts = this._keyOpts || { passive: false, capture: true };
              window.removeEventListener('keydown', this._onKeyDown, opts);
              window.removeEventListener('keyup', this._onKeyUp, opts);
              document.removeEventListener('keydown', this._onKeyDown, opts);
              document.removeEventListener('keyup', this._onKeyUp, opts);
            } catch (e) {}
            try { window.removeEventListener('blur', this._clearKeys); } catch (e) {}
          },
          _refreshColliders: function () { this._colliders = Array.from(this.el.sceneEl.querySelectorAll('.collider')); },
          _getYaw: function () {
            const cam = document.getElementById('playerCam');
            const lc = cam && cam.components && cam.components['look-controls'];
            if (lc && lc.yawObject) return lc.yawObject.rotation.y;
            return cam ? cam.object3D.rotation.y : 0;
          },
          _aabbExpanded: function (el, radius) {
            const pos = el.object3D.getWorldPosition(this._tmpVec3);
            const w = parseFloat(el.getAttribute('width'))  || 1;
            const d = parseFloat(el.getAttribute('depth'))  || 1;
            return { minX: pos.x - w/2 - radius, maxX: pos.x + w/2 + radius, minZ: pos.z - d/2 - radius, maxZ: pos.z + d/2 + radius };
          },
          _resolveX: function (x, z, dx, radius) {
            let nx = x + dx;
            for (let i = 0; i < this._colliders.length; i++) {
              const a = this._aabbExpanded(this._colliders[i], radius);
              if (nx > a.minX && nx < a.maxX && z > a.minZ && z < a.maxZ) nx = (dx > 0) ? (a.minX - EPS) : (a.maxX + EPS);
            }
            return nx;
          },
          _resolveZ: function (x, z, dz, radius) {
            let nz = z + dz;
            for (let i = 0; i < this._colliders.length; i++) {
              const a = this._aabbExpanded(this._colliders[i], radius);
              if (x > a.minX && x < a.maxX && nz > a.minZ && nz < a.maxZ) nz = (dz > 0) ? (a.minZ - EPS) : (a.maxZ + EPS);
            }
            return nz;
          },
          tick: function (t, dt) {
            if (t - this._lastColliderRefresh > 1500) { this._refreshColliders(); this._lastColliderRefresh = t; }

            const dtS = Math.min(0.05, dt / 1000);
            const speed = this.data.speed;
            const r = this.data.radius;

            const w = !!this.keys['KeyW'] || !!this.keys['ArrowUp'];
            const s = !!this.keys['KeyS'] || !!this.keys['ArrowDown'];
            const a = !!this.keys['KeyA'] || !!this.keys['ArrowLeft'];
            const d = !!this.keys['KeyD'] || !!this.keys['ArrowRight'];

            let f = (w ? 1 : 0) - (s ? 1 : 0);
            let str = (d ? 1 : 0) - (a ? 1 : 0);
            if (f === 0 && str === 0) return;

            const mag = Math.hypot(str, f);
            if (mag > 1e-6) { str /= mag; f /= mag; }

            const yaw = this._getYaw();
            const sin = Math.sin(yaw), cos = Math.cos(yaw);

            const forwardX = -sin, forwardZ = -cos;
            const rightX = cos, rightZ = -sin;

            const moveX = (rightX * str + forwardX * f) * speed * dtS;
            const moveZ = (rightZ * str + forwardZ * f) * speed * dtS;

            const pos = this.el.object3D.position;
            const nx = this._resolveX(pos.x, pos.z, moveX, r);
            const nz = this._resolveZ(nx, pos.z, moveZ, r);
            pos.x = nx; pos.z = nz;
          }
        });

        // --- Fix: ensure rig-walk attaches even if markup was parsed before this component registered ---
        // If the rig entity existed before the component was registered, A-Frame won't auto-initialize it.
        // We force a re-parse by removing + re-setting the attribute once the scene is ready.
        (function ensureRigWalkAttached(){
          const scene = document.querySelector('a-scene');
          const attach = () => {
            const rig = document.getElementById('rig');
            if (!rig) return;
            if (rig.components && rig.components['rig-walk']) return;
            const raw = rig.getAttribute('rig-walk') || 'speed: 2.6; radius: 0.28';
            rig.removeAttribute('rig-walk');
            rig.setAttribute('rig-walk', raw);
          };
          if (!scene) { window.addEventListener('load', attach, { once: true }); return; }
          if (scene.hasLoaded) attach();
          else scene.addEventListener('loaded', attach, { once: true });
        })();

        // --- WASD reliability: ensure scene/canvas can receive keyboard focus ----------------------
        (function ensureWASDFocus(){
          const scene = document.querySelector('a-scene');
          const focusScene = () => {
            try { scene && scene.focus && scene.focus(); } catch(e){}
            try {
              if (scene && scene.canvas) {
                scene.canvas.setAttribute('tabindex', '0');
                scene.canvas.focus();
              }
            } catch(e){}
          };

          if (!scene) { window.addEventListener('load', focusScene, { once: true }); return; }

          // Make both the scene and canvas focusable.
          try { scene.setAttribute('tabindex', '0'); } catch(e){}
          if (scene.hasLoaded) {
            focusScene();
          } else {
            scene.addEventListener('loaded', () => {
              focusScene();
            }, { once: true });
          }

          // Any click/tap on the page re-focuses (helps when the user clicks UI / loses focus).
          window.addEventListener('mousedown', focusScene, { passive: true });
          window.addEventListener('touchstart', focusScene, { passive: true });
        })();

      })();
    </script>
<script>

/**
 * Concept notes embedded in behavior:
 * - Only light in the room comes from the "people" (nodes).
 * - You encounter the system at mid-life: already decaying, flickering, fading.
 * - Closer to core = crowded, drained (non-creative compression).
 * - Far edge = disconnected, also fading (too far from the network to exist).
 */

AFRAME.registerComponent('fear-network',{
  init(){
    /**
     * v6 (Decaying Constellation + Global Blackouts)
     * - 200 nodes, redistributed evenly across: sphere web, floor roots, ceiling roots.
     * - Surface-root nodes are intentionally dimmer.
     * - Per-node random baseline intensity + single-node flicker (dying star feel).
     * - Occasional global network blackouts (brief, irregular) to amplify decay.
     */

    // Grab Player Light for blackout sync
    this.playerLight = document.getElementById('headLamp');

    // Pillar extents in local Station2 space (pre-scale)
    this.minY = 0.20;
    this.maxY = 14.70;
    this.coreY = 7.20;

    this.lifeSeconds = 120;
    this.meetOffsetSeconds = 60;
    this.startTime = performance.now();

    this.UNIFORM_SPEED_MS = 1 / (this.lifeSeconds*1000);
    this.UNIFORM_OMEGA_MS = (Math.PI*2/this.lifeSeconds)/1000;

    this.movers = [];
    this.edgeMovers = [];
    this.coreDust = [];

    // Main web (cheap lines)
    this.branchMaterial = new THREE.LineBasicMaterial({
      color: 0x0b0b0b,
      transparent: true,
      opacity: 0.014
    });
    this.branchPositions = [];
    this.branchObject = null;

    // Surface-root layers (even fainter, progressive fade)
    this.spreadNearMat = new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.010 });
    this.spreadMidMat  = new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.006 });
    this.spreadFarMat  = new THREE.LineBasicMaterial({ color: 0x0b0b0b, transparent: true, opacity: 0.003 });
    this.spreadNear = [];
    this.spreadMid  = [];
    this.spreadFar  = [];
    this.spreadObjNear = null;
    this.spreadObjMid  = null;
    this.spreadObjFar  = null;

    // Physical wire presence (kept subtle)
    this.branchMesh = null;

    // PERF
    this.realLightBudget = 26;
    this.realLightsCreated = 0;
    this.branchSampleRate = 0.08;

    this.leafPaths = [];          // sphere attachment paths (movement)
    this.rootPaths = [];          // all surface-root paths (movement)
    this.floorRootPaths = [];     // floor-only surface roots
    this.ceilRootPaths  = [];     // ceiling-only surface roots

    this._buildNetworkSphere();
    this._commitBranches();
    this._seedCoreDust();
  },

  // --- NETWORK GENERATION ----------------------------------------------------
  _buildNetworkSphere(){
    const pillarR = 0.86;        // attachment radius around monolith
    const centerY = this.coreY;
    const sphereR = 7.50;        // a bit wider to read as "sphere"
    const minY = this.minY + 0.06;
    const maxY = this.maxY - 0.10;

    // Sphere lattice
    const anchorCount = 150;
    const latCount = 16;
    const lonSeg = 40;

    // Neatness / decay
    const frayCount = 26;
    const attachCount = 200;

    const anchors = [];

    // 1) Pillar anchors (full height)
    for(let i=0;i<anchorCount;i++){
      const y = minY + Math.random()*(maxY-minY);
      const a = Math.random()*Math.PI*2;
      anchors.push({
        x: Math.cos(a)*pillarR,
        y: y,
        z: Math.sin(a)*pillarR
      });
    }

    // 2) Build sphere lattice rings
    const latticeRings = [];
    const latticePts = [];

    for(let r=0;r<latCount;r++){
      const v = (r/(latCount-1))*2 - 1;           // -1..1
      const rr = Math.sqrt(Math.max(0,1-v*v))*sphereR;
      const y = centerY + v*sphereR;

      // Keep within extents, but preserve spherical read
      const yy = Math.min(maxY, Math.max(minY, y));
      const twist = (r%2?0.5:0.0) * (Math.PI*2/lonSeg);

      const ring = [];
      for(let s=0;s<lonSeg;s++){
        const a = (s/lonSeg)*Math.PI*2 + twist;
        const p = {
          x: Math.cos(a)*rr + (Math.random()-.5)*0.05,
          y: yy + (Math.random()-.5)*0.05,
          z: Math.sin(a)*rr + (Math.random()-.5)*0.05
        };
        ring.push(p);
        latticePts.push(p);
      }
      latticeRings.push(ring);
    }

    // Ring neighbors + vertical stitches
    for(let r=0;r<latticeRings.length;r++){
      const ring = latticeRings[r];
      const nextRing = latticeRings[r+1] || null;
      for(let s=0;s<ring.length;s++){
        const p0 = ring[s];
        const p1 = ring[(s+1)%ring.length];
        this._addSegment(p0,p1);

        if(nextRing){
          const p2 = nextRing[(s + (r%2?1:0)) % nextRing.length];
          this._addSegment(p0,p2);
        }
      }
    }

    // 3) Light fray (subtle, to feel dying)
    const outerPts = latticePts.slice().sort(()=>Math.random()-0.5).slice(0, frayCount);
    for(let i=0;i<outerPts.length;i++){
      const p0 = outerPts[i];
      const a = Math.random()*Math.PI*2;
      const p1 = {
        x: p0.x + Math.cos(a)*(0.60 + Math.random()*1.35),
        y: p0.y + (Math.random()-.5)*0.65,
        z: p0.z + Math.sin(a)*(0.60 + Math.random()*1.35)
      };
      this._addPolyline(this._makePath(p0,p1,4,0.10));
    }

    // Helper: pick anchor near y (10 tries)
    const pickAnchorNearY = (y, biasLow=false, biasHigh=false) => {
      let best = anchors[(Math.random()*anchors.length)|0];
      let bestD = 1e9;
      for(let t=0;t<10;t++){
        const a = anchors[(Math.random()*anchors.length)|0];
        const d = Math.abs(a.y - y);
        if(biasLow  && a.y > 2.6)  continue;
        if(biasHigh && a.y < 12.2) continue;
        if(d < bestD){ bestD = d; best = a; }
      }
      return best;
    };

    // 4) Outer → pillar attachments (motion paths)
    const sources = latticePts.slice().sort(()=>Math.random()-0.5).slice(0, attachCount);
    for(let i=0;i<sources.length;i++){
      const outer = sources[i];
      const a0 = pickAnchorNearY(outer.y);
      const path = this._makePath(outer, a0, 7, 0.070);
      this._addPolyline(path);

      // occasional small constriction wrap
      if(Math.random() < 0.14){
        const a1 = pickAnchorNearY(a0.y);
        this._addPolyline(this._makePath(a0, a1, 4, 0.045));
      }

      this.leafPaths.push(path);
    }

    // 5) FLOOR + CEILING ROOT SPREAD (progressive fade + attached tails)
    const floorY = 0.06;
    const ceilY  = maxY;

    const maxRad = 18.8;      // spreads farther (after Station2 scale, reaches the room edges)
    const rayCount = 96;      // root rays on each surface
    const nearBand = 6.0;
    const midBand  = 12.0;

    const addSpreadSeg = (p0,p1) => {
      // classify by radius (progressive disappearance)
      const r0 = Math.hypot(p0.x,p0.z);
      const r1 = Math.hypot(p1.x,p1.z);
      const r = (r0+r1)*0.5;
      const arr = (r < nearBand) ? this.spreadNear : (r < midBand ? this.spreadMid : this.spreadFar);
      arr.push(p0.x,p0.y,p0.z, p1.x,p1.y,p1.z);
    };

    const addSpreadPolyline = (pts) => {
      for(let i=0;i<pts.length-1;i++) addSpreadSeg(pts[i], pts[i+1]);
    };

    const makeSurfaceTail = (pStart, pEnd, steps, jitter) => {
      // Like _makePath but y stays glued to surface (attached)
      const pts = [pStart];
      for(let i=1;i<steps;i++){
        const t=i/steps;
        pts.push({
          x: pStart.x + (pEnd.x-pStart.x)*t + (Math.random()-.5)*jitter,
          y: pStart.y,
          z: pStart.z + (pEnd.z-pStart.z)*t + (Math.random()-.5)*jitter
        });
      }
      pts.push(pEnd);
      return pts;
    };

    const buildSurfaceRoots = (isFloor) => {
      const y = isFloor ? floorY : ceilY;
      const roots = [];

      for(let i=0;i<rayCount;i++){
        const a = (i/rayCount)*Math.PI*2 + (Math.random()-.5)*0.06;
        const rNear = 2.0 + Math.random()*1.8;
        const rFar  = (isFloor ? 0.75 : 0.70) * maxRad + Math.random()* (0.30*maxRad);

        const pNear = { x: Math.cos(a)*rNear, y, z: Math.sin(a)*rNear };
        const pFar  = { x: Math.cos(a)*rFar,  y, z: Math.sin(a)*rFar  };

        // attach to pillar via a low/high anchor first (keeps "feeding loop" idea)
        const a0 = isFloor ? pickAnchorNearY(1.2, true, false) : pickAnchorNearY(13.8, false, true);

        // descent/ascent to surface (y becomes glued at end)
        const bridge = this._makePath(a0, pNear, 6, 0.085);
        // force last two points onto the surface for "attachment"
        bridge[bridge.length-1].y = y;
        bridge[bridge.length-2].y = y;

        // long attached tail along the surface, progressively fading
        const tail = makeSurfaceTail(pNear, pFar, 10, 0.14);

        // add spread geometry
        addSpreadPolyline(tail);

        // also add the near bridge into the main web so the root feels structurally connected
        this._addPolyline(bridge);

        // combine into a motion path so nodes can travel on these roots
        const motion = bridge.concat(tail.slice(1));
        roots.push(motion);
      }

      // Add faint circumferential “mat” rings (also fading)
      const ringSeg = 80;
      const ringCount = 3;
      for(let k=0;k<ringCount;k++){
        const rr = (k===0?4.8:(k===1?9.8:15.8)) + (Math.random()-.5)*0.4;
        const pts = [];
        for(let j=0;j<ringSeg;j++){
          const a = (j/ringSeg)*Math.PI*2;
          pts.push({ x: Math.cos(a)*rr, y, z: Math.sin(a)*rr });
        }
        // ring polyline
        for(let j=0;j<pts.length;j++){
          const p0 = pts[j];
          const p1 = pts[(j+1)%pts.length];
          addSpreadSeg(p0,p1);
        }
      }

      return roots;
    };

    const floorRoots = buildSurfaceRoots(true);
    const ceilRoots  = buildSurfaceRoots(false);

    // Keep separate references (for even distribution)
    this.floorRootPaths = floorRoots;
    this.ceilRootPaths  = ceilRoots;

    // Keep rootPaths for nodes (some will be spawned here)
    this.rootPaths.push(...floorRoots, ...ceilRoots);

    // 6) Sphere-to-surface “drips/climbs” (adds contact points)
    const bottomBand = latticePts.filter(p => p.y < centerY - sphereR*0.55);
    const topBand    = latticePts.filter(p => p.y > centerY + sphereR*0.55);

    for(let k=0;k<34;k++){
      const p0 = bottomBand[(Math.random()*bottomBand.length)|0];
      const a = Math.random()*Math.PI*2;
      const r = 6.0 + Math.random()* (maxRad-6.0);
      const p1 = { x: Math.cos(a)*r, y: floorY, z: Math.sin(a)*r };
      const drip = this._makePath(p0, p1, 6, 0.095);
      drip[drip.length-1].y = floorY;
      this._addPolyline(drip);
    }

    for(let k=0;k<34;k++){
      const p0 = topBand[(Math.random()*topBand.length)|0];
      const a = Math.random()*Math.PI*2;
      const r = 6.0 + Math.random()* (maxRad-6.0);
      const p1 = { x: Math.cos(a)*r, y: ceilY, z: Math.sin(a)*r };
      const climb = this._makePath(p0, p1, 6, 0.095);
      climb[climb.length-1].y = ceilY;
      this._addPolyline(climb);
    }


    // --- Spawn movers (nodes) ------------------------------------------------
    const desiredNodes = 200;

    // Even redistribution across: sphere web, floor roots, ceiling roots
    const targets = {
      sphere: Math.floor(desiredNodes/3),
      floor:  Math.floor(desiredNodes/3),
      ceil:   Math.floor(desiredNodes/3)
    };
    let rem = desiredNodes - (targets.sphere + targets.floor + targets.ceil);
    if (rem-- > 0) targets.sphere++;
    if (rem-- > 0) targets.floor++;
    if (rem-- > 0) targets.ceil++;

    const spawnFrom = (paths, count, surfaceMul, edgeProb) => {
      if (!paths || paths.length === 0 || count <= 0) return;
      const shuffled = paths.slice().sort(()=>Math.random()-0.5);
      for (let i=0;i<count;i++){
        const poly = shuffled[i % shuffled.length];
        const startRadius = Math.hypot(poly[0].x, poly[0].z);
        const isEdge = Math.random() < edgeProb;
        if (isEdge) this._spawnEdgeMover(poly, startRadius, surfaceMul);
        else this._spawnMover(poly, startRadius, surfaceMul);
      }
    };

    // Sphere is the main constellation; surface roots are dimmer afterglow.
    spawnFrom(this.leafPaths,       targets.sphere, 1.00, 0.22);
    spawnFrom(this.floorRootPaths,  targets.floor,  0.55, 0.36);
    spawnFrom(this.ceilRootPaths,   targets.ceil,   0.55, 0.36);

  },

  _addSegment(p0,p1){
    this.branchPositions.push(p0.x,p0.y,p0.z, p1.x,p1.y,p1.z);
  },

  _addPolyline(pts){
    for(let i=0;i<pts.length-1;i++){
      this._addSegment(pts[i], pts[i+1]);
    }
  },

  _makePath(a,b,steps=6,jitter=0.14){
    const pts=[a];
    for(let i=1;i<steps;i++){
      const t=i/steps;
      pts.push({
        x:a.x+(b.x-a.x)*t+(Math.random()-.5)*jitter,
        y:a.y+(b.y-a.y)*t+(Math.random()-.5)*(jitter*0.55),
        z:a.z+(b.z-a.z)*t+(Math.random()-.5)*jitter
      });
    }
    pts.push(b);
    return pts;
  },

  // --- GEOMETRY COMMIT ------------------------------------------------------
  _commitBranches(){
    if(this.branchObject) return;

    // Main web
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(this.branchPositions, 3));
    const lines = new THREE.LineSegments(geom, this.branchMaterial);
    this.el.object3D.add(lines);
    this.branchObject = lines;

    // Surface-root layers (fading)
    const addSpreadLines = (arr, mat) => {
      if(!arr || arr.length===0) return null;
      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.Float32BufferAttribute(arr, 3));
      const l = new THREE.LineSegments(g, mat);
      this.el.object3D.add(l);
      return l;
    };
    this.spreadObjNear = addSpreadLines(this.spreadNear, this.spreadNearMat);
    this.spreadObjMid  = addSpreadLines(this.spreadMid,  this.spreadMidMat);
    this.spreadObjFar  = addSpreadLines(this.spreadFar,  this.spreadFarMat);

    // Physical wire geometry sampled (subtle)
    const segCountAll = Math.floor(this.branchPositions.length / 6);
    if(segCountAll === 0) return;

    const up = new THREE.Vector3(0,1,0);
    const a = new THREE.Vector3();
    const b = new THREE.Vector3();
    const mid = new THREE.Vector3();
    const dir = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    const sca = new THREE.Vector3(1,1,1);
    const mat4 = new THREE.Matrix4();

    const picked = [];
    for(let i=0;i<segCountAll;i++){
      const idx = i*6;
      a.set(this.branchPositions[idx],   this.branchPositions[idx+1], this.branchPositions[idx+2]);
      b.set(this.branchPositions[idx+3], this.branchPositions[idx+4], this.branchPositions[idx+5]);
      const len = a.distanceTo(b);
      const keep = (len > 0.35 && Math.random() < this.branchSampleRate) || (len > 0.80);
      if(keep) picked.push(i);
    }

    const segCount = picked.length;
    if(segCount===0) return;

    const cylGeom = new THREE.CylinderGeometry(0.0014, 0.0014, 1, 6, 1, true); // thinner
    const branchMat = new THREE.MeshStandardMaterial({
      color: 0x030303,
      roughness: 0.88,
      metalness: 0.18
    });

    const inst = new THREE.InstancedMesh(cylGeom, branchMat, segCount);
    inst.frustumCulled = false;

    for(let k=0;k<segCount;k++){
      const i = picked[k];
      const idx = i*6;
      a.set(this.branchPositions[idx],   this.branchPositions[idx+1], this.branchPositions[idx+2]);
      b.set(this.branchPositions[idx+3], this.branchPositions[idx+4], this.branchPositions[idx+5]);

      dir.subVectors(b,a);
      const len = Math.max(0.001, dir.length());
      dir.normalize();

      mid.addVectors(a,b).multiplyScalar(0.5);
      quat.setFromUnitVectors(up, dir);
      sca.set(1, len, 1);

      mat4.compose(mid, quat, sca);
      inst.setMatrixAt(k, mat4);
    }
    inst.instanceMatrix.needsUpdate = true;

    this.el.object3D.add(inst);
    this.branchMesh = inst;
  },

  // --- NODES ----------------------------------------------------------------

  _makeNode(surfaceMul=1.0){
    const s=document.createElement('a-sphere');
    s.setAttribute('radius',0.03);
    s.setAttribute('material','color:#000;emissive:#ffffff;emissiveIntensity:3.8;metalness:0.18;roughness:0.28');

    if(this.realLightsCreated < this.realLightBudget){
      const light=document.createElement('a-entity');
      light.setAttribute('light','type:point;intensity:15.0;distance:18.0;decay:2;castShadow:false'); // Shadows from nodes too expensive
      s.appendChild(light);
      this.realLightsCreated++;
    }

    this.el.appendChild(s);

    // Per-node "decay personality" (random baseline + independent flicker)
    const baseMul   = 0.55 + Math.random()*0.90;    // random brightness baseline
    const flickRate = 0.75 + Math.random()*2.90;    // Hz-ish
    const flickPhase= Math.random()*Math.PI*2;
    const spikeRate = 0.25 + Math.random()*1.35;    // rare dropouts
    const spikePhase= Math.random()*Math.PI*2;

    return { el:s, baseMul, surfaceMul, flickRate, flickPhase, spikeRate, spikePhase };
  },

  _spawnMover(poly,startRadius,surfaceMul=1.0){
    const n=this._makeNode(surfaceMul);
    this.movers.push({
      el:n.el, poly, u:Math.random(), startRadius,
      baseMul:n.baseMul, surfaceMul:n.surfaceMul,
      flickRate:n.flickRate, flickPhase:n.flickPhase,
      spikeRate:n.spikeRate, spikePhase:n.spikePhase
    });
  },

  _spawnEdgeMover(poly,startRadius,surfaceMul=1.0){
    const n=this._makeNode(surfaceMul);
    this.edgeMovers.push({
      el:n.el,
      poly,
      phase:Math.random()*Math.PI*2,
      edgeRange:0.42+Math.random()*0.14,
      startRadius,
      baseMul:n.baseMul, surfaceMul:n.surfaceMul,
      flickRate:n.flickRate, flickPhase:n.flickPhase,
      spikeRate:n.spikeRate, spikePhase:n.spikePhase
    });
  },

  _seedCoreDust(){
    const dustCount=10;
    for(let i=0;i<dustCount;i++){
      const s=document.createElement('a-sphere');
      s.setAttribute('radius',0.024);
      s.setAttribute('material','color:#000;emissive:#ffffff;emissiveIntensity:2.2;metalness:0.1;roughness:0.35');
      this.el.appendChild(s);

      const r=0.14+Math.random()*0.42;
      const a=Math.random()*Math.PI*2;
      const y=this.coreY+(Math.random()*2.3-1.15);
      s.object3D.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
      this.coreDust.push({ el:s, seed:Math.random()*10, r });
    }
  },


  // --- ANIMATION ------------------------------------------------------------
  tick(t,dt){
    if(!dt || dt<=0) dt=16;

    const now=performance.now();
    const age = (now - this.startTime)/1000 + this.meetOffsetSeconds;

    const phase = (age % this.lifeSeconds) / this.lifeSeconds;
    const global = Math.max(0.06, 1 - phase);
    const time = age;
    const globalFlick = 0.78 + Math.sin(time*1.35)*0.10 + Math.sin(time*3.90 + 0.60)*0.07 + Math.sin(time*8.80 + 1.90)*0.04;

    // Brief, irregular network-wide blackouts
    const power = this._globalBlackout(time);

    // Sync player flashlight to grid power (includes pre-blackout flicker)
    // It shouldn't die completely (it's battery), but it should brownout + flicker with the grid.
    if(this.playerLight) {
        // 0.05 in full blackout, ~0.8 at full power. Flicker state will modulate this automatically.
        const lightState = 0.05 + power * 0.75;
        this.playerLight.setAttribute('light', 'intensity', lightState);
    }

const du = this.UNIFORM_SPEED_MS * dt;

    for(const m of this.movers){
      m.u += du;
      if(m.u>=1) m.u-=1;

      const p=this._sample(m.poly,m.u);
      m.el.object3D.position.set(p.x,p.y,p.z);

      const r = Math.hypot(p.x, p.z);
      const radial = this._radialAtten(r);

      const corePull = Math.min(1, Math.pow(m.u, 1.18) * 1.10);
      const edge = Math.max(0, 1 - (m.u/0.22));
      const far = Math.min(1, (m.startRadius-2.0)/3.2);
      const disconnect = Math.min(1, edge*0.70 + far*0.55);

      const stress = Math.max(corePull, disconnect);
      const flick = (stress>0.55)
        ? (0.72 + Math.sin(time*2.1 + m.u*8.0)*0.20 + Math.sin(time*4.0 + m.u*4.5)*0.08)
        : 1.0;

      let intensity = global * globalFlick;
      intensity *= (1 - 0.90*corePull);
      intensity *= (1 - 0.78*disconnect);
      intensity = Math.max(0.0, intensity) * flick;

      // Per-node randomness + dying-star flicker + global blackouts
      intensity *= this._nodeMod(m, time) * power * radial;

      this._applyNodeIntensity(m.el, intensity, power);
    }

    for(const m of this.edgeMovers){
      m.phase += this.UNIFORM_OMEGA_MS * dt;
      const u = (0.5 + Math.sin(m.phase)*0.5) * m.edgeRange;
      const p=this._sample(m.poly,u);
      m.el.object3D.position.set(p.x,p.y,p.z);

      const r = Math.hypot(p.x, p.z);
      const radial = this._radialAtten(r);

      const edge = Math.max(0, 1 - (u/0.24));
      const far = Math.min(1, (m.startRadius-2.0)/3.2);
      const disconnect = Math.min(1, 0.56 + edge*0.34 + far*0.32);

      const flick = 0.88 + Math.sin(time*1.35 + m.phase*2.0)*0.09;
      let intensity = global * globalFlick * (1 - 0.92*disconnect) * flick;
      intensity = Math.max(0.0, intensity) * (0.25 + global*0.75);

      intensity *= this._nodeMod(m, time) * power * radial;

      this._applyNodeIntensity(m.el, intensity, power);
    }

    for(const d of this.coreDust){
      const wob = 0.88 + Math.sin(time*2.6 + d.seed)*0.09 + Math.sin(time*4.7 + d.seed*2.0)*0.05;
      let intensity = global * 0.22 * wob;
      const gasp = (Math.sin(time*0.95 + d.seed*3.0) > 0.88) ? 1.55 : 1.0;
      intensity *= gasp;

      // Dust obeys global blackouts too (it's part of the system breathing)
      intensity *= power;

      const mesh=d.el.getObject3D('mesh');
      if(mesh && mesh.material){
        if (power <= 0.0) {
        mesh.material.emissiveIntensity = 0.0;
      } else {
        mesh.material.emissiveIntensity = (0.15 + Math.pow(Math.max(0,intensity),0.85)*6.0) * 0.20;
      }
      }
    }

    // Web visibility also "breathes" + participates in blackouts (more perceptible decay)
const webBase = 0.010 + global*0.010;

const structureFlick =
  0.50
  + (Math.sin(time*3.40)*0.5+0.5) * 0.40
  + (Math.sin(time*9.00 + 1.20)*0.5+0.5) * 0.30;

const webMul = power * structureFlick * (globalFlick / 0.78);

this.branchMaterial.opacity = webBase * webMul;

const spreadBase = (0.55 + global*0.45) * webMul;
this.spreadNearMat.opacity = 0.010 * spreadBase;
this.spreadMidMat.opacity  = 0.006 * spreadBase;
this.spreadFarMat.opacity  = 0.003 * spreadBase;

    if(this.branchMesh && this.branchMesh.material){
      const m = this.branchMesh.material;
      m.roughness = 0.90 - global*0.08;
      m.needsUpdate = true;
    }
  },

  _globalBlackout(time) {
  /**
   * Randomized blackout cycle with pre-blackout flicker.
   *
   * Cycle:
   *   ON for a random duration (default 3.0–7.0s)
   *   FLICKER for a short duration (default 0.55–1.15s)
   *   BLACKOUT (all nodes OFF) for exactly 2.0s
   *
   * Returns grid power in [0..1]. During BLACKOUT it is hard 0.0.
   */
  if (!this._bo) {
    const onDur = this._randRange(3.0, 7.0);
    const flickDur = this._randRange(0.55, 1.15);
    this._bo = {
      state: 'on',   // 'on' | 'flicker' | 'off'
      t0: time,
      t1: time + onDur,
      onMin: 3.0, onMax: 7.0,
      flickMin: 0.55, flickMax: 1.15,
      offDur: 2.0,
      seed: Math.random() * 1000
    };
  }

  const b = this._bo;

  // If time jumps backwards (rare), re-seed cleanly.
  if (time < b.t0 - 0.5) {
    this._bo = null;
    return this._globalBlackout(time);
  }

  // Advance state machine until it contains 'time'.
  for (let guard = 0; guard < 8; guard++) {
    if (b.state === 'on') {
      if (time < b.t1) return 1.0;
      b.state = 'flicker';
      b.t0 = b.t1;
      b.t1 = b.t0 + this._randRange(b.flickMin, b.flickMax);
      b.seed = Math.random() * 1000;
      continue;
    }

    if (b.state === 'flicker') {
      if (time < b.t1) {
        const u = (time - b.t0) / Math.max(0.001, (b.t1 - b.t0)); // 0..1
        // Fast, irregular flicker: mix a few sines + a hashed step jitter.
        const hz = 18 + (b.seed % 11); // 18..29-ish
        const s1 = 0.5 + 0.5 * Math.sin((time * hz) + b.seed);
        const s2 = 0.5 + 0.5 * Math.sin((time * (hz * 0.55)) + b.seed * 1.7);
        const step = this._hash01(Math.floor((time - b.t0) * 60) + Math.floor(b.seed * 10.0));
        // Bias darker as it approaches blackout.
        let p = (s1 * 0.45 + s2 * 0.25 + step * 0.30);
        p = 0.12 + p * 0.88;
        p *= (1.0 - 0.78 * u);
        // Occasional “hard blink” in flicker phase.
        if (step > 0.92) p *= 0.05;
        return Math.max(0.0, Math.min(1.0, p));
      }
      b.state = 'off';
      b.t0 = b.t1;
      b.t1 = b.t0 + b.offDur;
      continue;
    }

    // BLACKOUT
    if (b.state === 'off') {
      if (time < b.t1) return 0.0;
      b.state = 'on';
      b.t0 = b.t1;
      b.t1 = b.t0 + this._randRange(b.onMin, b.onMax);
      b.seed = Math.random() * 1000;
      continue;
    }
  }

  // Failsafe (shouldn't happen)
  return (b.state === 'off') ? 0.0 : 1.0;
},

_randRange(a, b) { return a + Math.random() * (b - a); },
_hash01(n) {
  // Deterministic pseudo-random in [0..1] from an integer.
  const x = Math.sin(n * 127.1) * 43758.5453123;
  return x - Math.floor(x);
},

_nodeMod(m, time){
    // Independent flicker + occasional single-node dropouts.
    let f = 0.78
      + Math.sin(time*m.flickRate + m.flickPhase)*0.18
      + Math.sin(time*(m.flickRate*2.6) + m.flickPhase*1.7)*0.10
      + Math.sin(time*(m.flickRate*6.1) + m.flickPhase*0.6)*0.05;

    const spike = Math.sin(time*(0.85 + m.spikeRate) + m.spikePhase);
    if (spike > 0.975) f *= 0.01;      // micro-blackout on one node
    else if (spike > 0.92) f *= 0.18;  // heavy flicker dip  // heavy flicker dip

    f *= m.baseMul;        // random baseline decay
    f *= m.surfaceMul;     // floor/ceiling nodes are dimmer
    return Math.max(0.0, f);
  },


_radialAtten(r){
  // Radial decay: further from pillar => weaker light.
  // r is in Station2 local space (pre-scale).
  const r0 = 0.90;   // near pillar
  const r1 = 19.50;  // farthest root spread
  let x = (r - r0) / (r1 - r0);
  x = Math.max(0, Math.min(1, x));
  
  // Power 3.0 creates a much steeper falloff, min 0.0 allows total darkness
  return Math.max(0.0, Math.pow(1 - x, 3.0));
},

  _applyNodeIntensity(nodeEl, intensity, gridPower = 1.0){
    // During blackout: nodes are truly OFF (no emissive floor, no point-light spill).
    if (gridPower <= 0.0) {
      const mesh = nodeEl.getObject3D('mesh');
      if (mesh && mesh.material) mesh.material.emissiveIntensity = 0.0;

      const light = nodeEl.querySelector('[light]');
      if (light) light.setAttribute('light', 'intensity', 0.0);
      return;
    }

    const boosted = Math.pow(Math.max(0, intensity), 0.85);

    const mesh = nodeEl.getObject3D('mesh');
    if (mesh && mesh.material){
      mesh.material.emissiveIntensity = (0.35 + boosted * 10.0) * 0.23;
    }

    const light = nodeEl.querySelector('[light]');
    if (light){
      const li = boosted * 18.0 * 0.20;
      const dist = 18.0 - boosted * 3.0;
      light.setAttribute('light', `intensity:${li.toFixed(3)};distance:${dist.toFixed(2)}`);
    }
  },

  _sample(poly,u){
    const seg = (poly.length-1);
    const i = Math.floor(u*seg);
    const a=poly[i], b=poly[i+1]||a;
    const t=u*seg - i;
    return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, z:a.z+(b.z-a.z)*t };
  }
});




AFRAME.registerComponent('monolith-inscriptions',{
  schema:{
    target:{type:'selector'}
  },
  init(){
    const core=this.data.target;
    if(!core) return;

    // Place faint "carved" text close to the surface. Visibility depends on node light reflection.
    const phrases=[
      "NO SPACE TO BREATHE",
      "TOO CLOSE: DRAINED",
      "TOO FAR: ERASED",
      "TASKS REPLACED",
      "THE NETWORK REMEMBERS",
      "WORK BECAME GRAVITY",
      "CREATIVITY COLLAPSED"
    ];

    // Four faces around the monolith
    const faces=[
      {rot:'0 0 0',   pos:'0 0 0.54'},
      {rot:'0 90 0',  pos:'0.54 0 0'},
      {rot:'0 180 0', pos:'0 0 -0.54'},
      {rot:'0 -90 0', pos:'-0.54 0 0'}
    ];

    faces.forEach((f,idx)=>{
      // Two small lines per face, placed high enough to feel "artifact"
      for(let r=0;r<2;r++){
        const txt=document.createElement('a-text');
        const phrase=phrases[(idx*2+r)%phrases.length];

        txt.setAttribute('value', phrase);
        txt.setAttribute('align','center');
        txt.setAttribute('baseline','center');
        txt.setAttribute('width','1.6');
        txt.setAttribute('color','#050505'); // almost black
        txt.setAttribute('opacity','0.85');
        txt.setAttribute('shader','msdf');
        txt.setAttribute('negate','false');

        // Slight extrusion illusion: duplicate a tiny offset to fake carving depth.
        const wrap=document.createElement('a-entity');
        wrap.setAttribute('position', f.pos);
        wrap.setAttribute('rotation', f.rot);

        // Position text on face: centered, but staggered
        const y = 6.60 - r*1.15;
        txt.setAttribute('position', `0 ${y} 0.001`); // barely off surface

        // Make it "carved" by giving it a slightly different specular behavior
        txt.setAttribute('material','metalness:0.95;roughness:0.18;transparent:true');

        const txt2=document.createElement('a-text');
        txt2.setAttribute('value', phrase);
        txt2.setAttribute('align','center');
        txt2.setAttribute('baseline','center');
        txt2.setAttribute('width','1.6');
        txt2.setAttribute('color','#000000');
        txt2.setAttribute('opacity','0.55');
        txt2.setAttribute('shader','msdf');
        txt2.setAttribute('position', `0 ${y} -0.006`);
        txt2.setAttribute('material','metalness:0.9;roughness:0.35;transparent:true');

        wrap.appendChild(txt2);
        wrap.appendChild(txt);
        this.el.appendChild(wrap);
      }
    });

    // Anchor inscriptions to core position so edits remain stable.
    const p = core.getAttribute('position');
    this.el.setAttribute('position', `${p.x} 0 ${p.z}`);
  }
});


/* ---------------------------------------------------------------------------
   Station 4: "Trapped Dataset" Monolith + Ivy Bridge
   - No external assets: procedural branches + custom shader for stuck mercury.
--------------------------------------------------------------------------- */

AFRAME.registerShader('mercury-sinuous', {
  schema: {
    time:   { type: 'time',   is: 'uniform' },
    flow:   { type: 'number', is: 'uniform', default: 0.0 },   // driven by component (stuck / move)
    pulse:  { type: 'number', is: 'uniform', default: 0.0 },   // reserved for future impulses
    opacity:{ type: 'number', is: 'uniform', default: 0.94 }
  },

  vertexShader: `
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vWorldNormal;

    void main() {
      vUv = uv;
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPos = worldPos.xyz;
      vWorldNormal = normalize(mat3(modelMatrix) * normal);
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `,

  fragmentShader: `
    precision highp float;

    uniform float time;
    uniform float flow;
    uniform float pulse;
    uniform float opacity;

    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vWorldNormal;

    // Hash + cheap value noise
    float hash31(vec3 p){
      p = fract(p * 0.1031);
      p += dot(p, p.yzx + 33.33);
      return fract((p.x + p.y) * p.z);
    }

    float noise(vec3 p){
      vec3 i = floor(p);
      vec3 f = fract(p);
      f = f*f*(3.0 - 2.0*f);

      float n000 = hash31(i + vec3(0,0,0));
      float n100 = hash31(i + vec3(1,0,0));
      float n010 = hash31(i + vec3(0,1,0));
      float n110 = hash31(i + vec3(1,1,0));
      float n001 = hash31(i + vec3(0,0,1));
      float n101 = hash31(i + vec3(1,0,1));
      float n011 = hash31(i + vec3(0,1,1));
      float n111 = hash31(i + vec3(1,1,1));

      float n00 = mix(n000, n100, f.x);
      float n10 = mix(n010, n110, f.x);
      float n01 = mix(n001, n101, f.x);
      float n11 = mix(n011, n111, f.x);

      float n0 = mix(n00, n10, f.y);
      float n1 = mix(n01, n11, f.y);

      return mix(n0, n1, f.z);
    }

    float fbm(vec3 p){
      float a = 0.55;
      float v = 0.0;
      for(int i=0;i<5;i++){
        v += a * noise(p);
        p *= 2.02;
        a *= 0.5;
      }
      return v;
    }

    void main() {
      // Extremely subtle motion: "it *should* flow, but it's trapped".
      float t = time * 0.001;
      float f = flow + t * 0.002; // near-imperceptible creep, even during "stuck"

      // Sinuous "S" drift primarily along height, with a tiny cross-current warp.
      float y = vWorldPos.y;
      vec3 p = vWorldPos * 0.58;

      float s1 = sin(y * 1.35 + f * 0.75);
      float s2 = sin(y * 0.88 - f * 0.62);
      p.x += 0.10 * s1;
      p.z += 0.08 * s2;

      // Secondary sinuous warps (reads as viscous internal circulation).
      p += 0.055 * vec3(
        sin(p.y * 1.90 + f * 0.55),
        sin(p.z * 2.20 - f * 0.43),
        sin(p.x * 2.05 + f * 0.50)
      );

      // Two scales: dense body + coagulated streaks.
      float body  = fbm(p * 1.35);
      float scum  = fbm(p * 3.40 + vec3(3.2, 1.1, 2.7));
      float spark = fbm(p * 8.50 + vec3(8.1, 2.4, 5.3));

      // High-contrast mercury: deep blacks + hard silvery plates.
      float m = smoothstep(0.26, 0.78, body);
      m = pow(m, 0.55);

      vec3 dark  = vec3(0.02);
      vec3 bright= vec3(0.92);
      vec3 col   = mix(dark, bright, m);

      // Coagulated bands (disgusting, metallic "wrongness")
      float band = smoothstep(0.46, 0.58, scum) * (1.0 - smoothstep(0.64, 0.86, scum));
      col -= vec3(0.32) * band;

      // Micro-sparkle only in highlights (like trapped reflectance in slurry).
      float spk = step(0.965, spark) * smoothstep(0.55, 0.95, m);
      col += vec3(0.12) * spk;

      // Fake reflectivity (Fresnel + crude environment)
      vec3 N = normalize(vWorldNormal);
      vec3 V = normalize(cameraPosition - vWorldPos);
      float fres = pow(1.0 - max(0.0, dot(N, V)), 4.0);

      vec3 R = reflect(-V, N);
      float envY = clamp(R.y * 0.5 + 0.5, 0.0, 1.0);
      float envX = clamp(0.5 + 0.5 * sin(R.x * 4.0 + R.z * 3.0), 0.0, 1.0);
      float envM = mix(envY, envX, 0.25);
      vec3 envCol = mix(vec3(0.04), vec3(0.98), envM);

      col = mix(col, envCol, 0.60 * fres);

      // Tight spec highlight (cinematic, not foggy)
      vec3 L = normalize(vec3(0.35, 0.92, 0.25));
      vec3 H = normalize(L + V);
      float spec = pow(max(0.0, dot(N, H)), 90.0);
      col += vec3(0.95) * spec * (0.55 + 0.45 * m);

      // Reserved: impulses can "stress" the mercury later.
      float pwr = clamp(pulse, 0.0, 1.0);
      col += vec3(0.10) * pwr;
      col = clamp(col, 0.0, 1.0);

      gl_FragColor = vec4(col, opacity);
    }
  `
});

// Drives the "stuck / move / stuck" flow so the motion feels trapped.
AFRAME.registerComponent('mercury-sinuous-driver', {
  schema: {
    cycle: { type: 'number', default: 28.0 },   // seconds
    move1: { type: 'number', default: 3.4 },
    pause1:{ type: 'number', default: 9.8 },
    move2: { type: 'number', default: 2.6 },
    speed1:{ type: 'number', default: 0.40 },   // flow units / sec (tiny)
    speed2:{ type: 'number', default: 0.26 }
  },
  init: function () {
    this.flow = 0.0;
    this._mat = null;
    this._nm1 = null;
    this._nm2 = null;

    const acquire = () => {
      const mesh = this.el.getObject3D('mesh');
      if (mesh && mesh.material && mesh.material.uniforms) this._mat = mesh.material;
    };

    acquire();
    if (!this._mat) {
      this.el.addEventListener('object3dset', acquire);
      this.el.addEventListener('model-loaded', acquire);
    }
  },
  tick: function (t, dt) {
    if (!this._mat || !this._mat.uniforms || !this._mat.uniforms.flow) return;

    const dts = Math.min(0.05, (dt || 16) / 1000);
    const cyc = Math.max(1.0, this.data.cycle);
    const ph  = (t * 0.001) % cyc;

    const a = this.data.move1;
    const b = a + this.data.pause1;
    const c = b + this.data.move2;

    let spd = 0.0;
    if (ph < a) spd = this.data.speed1;
    else if (ph >= b && ph < c) spd = this.data.speed2;

    // The actual movement is *tiny*.
    this.flow += spd * dts;

    this._mat.uniforms.flow.value = this.flow;
  }
});


/* ---------------------------------------------------------------------------
   Station 4 Monolith: Dense mercurial "liquid metal" (NO cloud volume)
   Approach:
   - Real Three.js PBR material (MeshPhysicalMaterial) with a procedural CubeTexture envMap
   - Animated procedural NORMAL MAP (CanvasTexture) that produces sinuous “S” currents
   - Motion uses move / pause / move / pause so it feels trapped
--------------------------------------------------------------------------- */

let __S4_STUDIO_ENV_TEX = null;
let __S4_STUDIO_ENV_RT  = null;
let __S4_STUDIO_ENV_SC  = null;
let __S4_STUDIO_ENV_CAM = null;

// Procedural "studio strip lights" envMap (no external HDRI).
// This is the *entire* trick: hard, cinematic highlights on a near-black reflective mass.
function __getS4StudioEnv(renderer){
  if (__S4_STUDIO_ENV_TEX) return __S4_STUDIO_ENV_TEX;
  if (!renderer) return null;

  const size = 128;
  const rt = new THREE.WebGLCubeRenderTarget(size, {
    generateMipmaps: true,
    minFilter: THREE.LinearMipmapLinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat
  });
  rt.texture.mapping = THREE.CubeReflectionMapping;
  if (rt.texture.colorSpace !== undefined) rt.texture.colorSpace = THREE.SRGBColorSpace;

  const cam = new THREE.CubeCamera(0.1, 60, rt);

  const sc = new THREE.Scene();
  sc.background = new THREE.Color(0x000000);

  // Dark enclosure (prevents "gray wash" reflections)
  const cage = new THREE.Mesh(
    new THREE.BoxGeometry(30, 30, 30),
    new THREE.MeshBasicMaterial({ color: 0x040405, side: THREE.BackSide })
  );
  sc.add(cage);

  function addStrip(w, h, pos, rot, a){
    const m = new THREE.Mesh(
      new THREE.PlaneGeometry(w, h),
      new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: a, side: THREE.DoubleSide })
    );
    m.position.copy(pos);
    m.rotation.set(rot.x, rot.y, rot.z);
    sc.add(m);
    // faint halo companion (makes strips feel photographic)
    const halo = new THREE.Mesh(
      new THREE.PlaneGeometry(w * 1.08, h * 1.55),
      new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: a * 0.12, side: THREE.DoubleSide })
    );
    halo.position.copy(pos);
    halo.rotation.copy(m.rotation);
    sc.add(halo);
  }

  // Key strips (front-ish, above, slight angle)
  addStrip(10.0, 0.85, new THREE.Vector3(0, 3.2, 7.6), new THREE.Euler(0, 0, 0), 1.0);
  addStrip(8.5,  0.55, new THREE.Vector3(-1.3, 1.0, 7.4), new THREE.Euler(0, 0.08, 0.05), 0.85);

  // Side strips (create vertical streaks when normals crawl)
  addStrip(9.5,  0.65, new THREE.Vector3(7.6, 0.8, 0), new THREE.Euler(0, -Math.PI/2, 0.10), 0.95);
  addStrip(9.0,  0.50, new THREE.Vector3(-7.6, -0.6, 0.5), new THREE.Euler(0,  Math.PI/2, -0.08), 0.70);

  // Top and bottom accents (gives "industrial studio" feel)
  addStrip(7.8, 0.55, new THREE.Vector3(0.3, 7.4, 0.2), new THREE.Euler(-Math.PI/2, 0.2, 0), 0.65);
  addStrip(7.2, 0.35, new THREE.Vector3(-0.4, -7.3, -0.6), new THREE.Euler(Math.PI/2, -0.25, 0), 0.25);

  // Small "hot spots" (spec hits)
  const dotGeo = new THREE.SphereGeometry(0.25, 12, 12);
  const dotMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const d1 = new THREE.Mesh(dotGeo, dotMat); d1.position.set(4.2, 2.2, 5.6); sc.add(d1);
  const d2 = new THREE.Mesh(dotGeo, dotMat); d2.position.set(-3.6, -1.8, 5.2); sc.add(d2);

  // Render once (static studio)
  cam.update(renderer, sc);

  __S4_STUDIO_ENV_TEX = rt.texture;
  __S4_STUDIO_ENV_RT = rt;
  __S4_STUDIO_ENV_SC = sc;
  __S4_STUDIO_ENV_CAM = cam;
  return __S4_STUDIO_ENV_TEX;
}



/*
  Station 4 — Mercury core performance pass
  Why this exists:
  The earlier version was generating *multiple* CPU canvas normal maps (per layer) every ~45–60ms.
  That tanks load time and causes stutter on many GPUs/CPUs.

  Fix:
  - ONE shared 128×128 canvas normal map for all mercury layers
  - Updated ~7 fps (140ms) with "creep → freeze → creep" flow
  - Materials are PBR (metal=1) and use the same procedural strip-light cube envMap
*/
(function(){
  const TWO_PI = Math.PI * 2;

  // Shared manager singleton
  const SHARED = window.__S4_MERCURY_SHARED || (window.__S4_MERCURY_SHARED = {
    size: 96,
    updateMS: 320,

    // trapped motion (seconds)
    cycle: 26.0,
    move1: 3.6,
    pause1: 11.4,
    move2: 2.8,
    speed1: 0.62, // "flow units / sec" (still subtle, but visible)
    speed2: 0.38,

    canvas: null,
    ctx: null,
    img: null,
    tex: null,

    lastMS: 0,
    flow: 0.0,

    _ensure: function(){
      if (this.tex) return;
      const c = document.createElement('canvas');
      c.width = c.height = this.size;
      const ctx = c.getContext('2d', { willReadFrequently: true });
      const img = ctx.createImageData(this.size, this.size);

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1, 1);
      tex.anisotropy = 1;
      // Normal maps must be linear / non-color data
      if (tex.colorSpace !== undefined && THREE.NoColorSpace !== undefined) tex.colorSpace = THREE.NoColorSpace;

      this.canvas = c;
      this.ctx = ctx;
      this.img = img;
      this.tex = tex;
      this.tex.needsUpdate = true;
    },

    _ease: function(x){
      // smoothstep-ish ease in/out (0..1)
      return (x < 0.5) ? (2 * x * x) : (1 - Math.pow(-2 * x + 2, 2) / 2);
    },

    _advanceFlow: function(timeMS){
      const t = timeMS / 1000;
      const tt = t % this.cycle;

      // dt capped to avoid huge jumps when tab is backgrounded
      const dt = Math.min(0.05, (timeMS - (this.lastMS || timeMS)) / 1000);

      if (tt < this.move1) {
        const a = this._ease(tt / this.move1);
        this.flow += this.speed1 * dt * a;
      } else if (tt < this.move1 + this.pause1) {
        // "stuck": barely-there twitch
        this.flow += 0.014 * dt * Math.sin(timeMS * 0.00022);
      } else if (tt < this.move1 + this.pause1 + this.move2) {
        const x = (tt - (this.move1 + this.pause1)) / this.move2;
        const a = this._ease(x);
        this.flow += this.speed2 * dt * a;
      } else {
        // end-of-cycle micro drift
        this.flow += 0.010 * dt * Math.sin(timeMS * 0.00017 + 1.3);
      }
    },

    _height: function(x, y, t0){
      // x,y in 0..1 space
      // Sheared coordinates give that sinuous "S" migration rather than straight scroll.
      const shear = 0.36;

      const u = (x * 1.85 + y * shear) * TWO_PI;
      const v = (y * 1.25 - x * shear * 0.85) * TWO_PI;
      const w = ((x + y) * 0.92) * TWO_PI;

      return (
        Math.sin(u + t0) +
        0.75 * Math.sin(v - t0 * 0.72) +
        0.55 * Math.sin(w + t0 * 0.38)
      );
    },

    _renderNormal: function(){
      const s = this.size;
      const data = this.img.data;

      // Small time scale: slow “crawl” (spec moves even when flow increments are tiny)
      const t0 = this.flow * 1.35;

      let k = 0;
      for (let j = 0; j < s; j++) {
        const y  = j / s;
        const y1 = ((j + 1) % s) / s;
        for (let i = 0; i < s; i++) {
          const x  = i / s;
          const x1 = ((i + 1) % s) / s;

          const h0 = this._height(x,  y,  t0);
          const hx = this._height(x1, y,  t0);
          const hy = this._height(x,  y1, t0);

          // Finite difference gradient -> normal
          const dx = (hx - h0);
          const dy = (hy - h0);

          // Base intensity (per-instance strength handled via normalScale)
          let nx = -dx * 2.8;
          let ny = -dy * 2.8;
          let nz = 1.0;

          const inv = 1.0 / Math.sqrt(nx*nx + ny*ny + nz*nz);
          nx *= inv; ny *= inv; nz *= inv;

          data[k++] = (nx * 0.5 + 0.5) * 255;
          data[k++] = (ny * 0.5 + 0.5) * 255;
          data[k++] = (nz * 0.5 + 0.5) * 255;
          data[k++] = 255;
        }
      }

      this.ctx.putImageData(this.img, 0, 0);
      this.tex.needsUpdate = true;
    },

    update: function(timeMS){
      this._ensure();
      if (!this.tex) return;

      if (this.lastMS && (timeMS - this.lastMS) < this.updateMS) return;

      this._advanceFlow(timeMS);
      this._renderNormal();
      this.lastMS = timeMS;
    }
  });

  // One tick hook for the whole scene
  AFRAME.registerComponent('s4-mercury-manager', {
    init: function () {
      this._didPR = false;
    },
    tick: function(time){
      // Cap pixel ratio a bit on high-DPI displays to reduce stutter (keeps highlights crisp).
      if (!this._didPR) {
        const r = this.el.renderer || (this.el.sceneEl && this.el.sceneEl.renderer);
        if (r && r.setPixelRatio) r.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
        this._didPR = true;
      }
      SHARED.update(time);
    }
  });
})();

AFRAME.registerComponent('mercury-liquid', {
  schema: {
    // Look
    normalSize:          { type: 'int',    default: 128 },
    updateMS:            { type: 'int',    default: 260 },
    normalStrength:      { type: 'number', default: 2.35 },
    normalRepeatX:       { type: 'number', default: 1.0 },
    normalRepeatY:       { type: 'number', default: 1.7 },
    metalness:          { type: 'number', default: 1.0 },
    roughness:          { type: 'number', default: 0.08 },
    envIntensity:       { type: 'number', default: 0.9 },
    opacity:            { type: 'number', default: 0.85 },
    clearcoat:          { type: 'number', default: 1.0 },
    clearcoatRoughness: { type: 'number', default: 0.10 },
    emissiveIntensity:  { type: 'number', default: 0.02 },

    // Motion (GPU-cheap: animate UV transforms instead of regenerating textures)
    flowScale:          { type: 'number', default: 0.22 }, // offset amplitude
    flowWobble:         { type: 'number', default: 0.42 },  // S-like wobble
    flowRotate:         { type: 'number', default: 0.22 }   // subtle rotation
  },

  init: function(){
    this._mat = null;

    const apply = () => {
      const mesh = this.el.getObject3D('mesh');
      const sceneEl = this.el.sceneEl;
      if (!mesh || !sceneEl || !sceneEl.renderer) return;

      const envTex = __getS4StudioEnv(sceneEl.renderer);
      const S = window.__S4_MERCURY_SHARED;
      if (S && S._ensure) S._ensure();
      const normalTex = S && S.tex;
      const normalTex2 = normalTex ? normalTex.clone() : null;

      const mat = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color('#020204'),
        metalness: this.data.metalness,
        roughness: this.data.roughness,
        clearcoat: this.data.clearcoat,
        clearcoatRoughness: this.data.clearcoatRoughness,
        envMap: envTex || null,
        envMapIntensity: this.data.envIntensity,
        normalMap: normalTex || null,
        clearcoatNormalMap: normalTex2 || null,
        normalScale: new THREE.Vector2(this.data.normalStrength, this.data.normalStrength),
        clearcoatNormalScale: new THREE.Vector2(this.data.normalStrength * 0.65, this.data.normalStrength * 0.65),
        transparent: (this.data.opacity < 0.999),
        opacity: this.data.opacity
      });

      mat.side = THREE.DoubleSide;
      mat.depthWrite = (this.data.opacity >= 0.999);

      mat.emissive = new THREE.Color('#040405');
      mat.emissiveIntensity = this.data.emissiveIntensity;

      
      // Texture transforms (very cheap) — makes motion *visible* without CPU texture regen.
      if (mat.normalMap) {
        mat.normalMap.wrapS = mat.normalMap.wrapT = THREE.RepeatWrapping;
        mat.normalMap.repeat.set(this.data.normalRepeatX, this.data.normalRepeatY);
        mat.normalMap.center.set(0.5, 0.5);
      }
      if (mat.clearcoatNormalMap) {
        mat.clearcoatNormalMap.wrapS = mat.clearcoatNormalMap.wrapT = THREE.RepeatWrapping;
        mat.clearcoatNormalMap.repeat.set(this.data.normalRepeatX * 1.35, this.data.normalRepeatY * 0.85);
        mat.clearcoatNormalMap.center.set(0.5, 0.5);
      }

      this._nm1 = mat.normalMap || null;
      this._nm2 = mat.clearcoatNormalMap || null;
mesh.traverse(o => { if (o.isMesh) o.material = mat; });

      this._mat = mat;
    };

    // Apply once ready
    if (this.el.sceneEl && this.el.sceneEl.renderer) apply();
    else this.el.sceneEl && this.el.sceneEl.addEventListener('renderstart', apply, { once: true });
  },

  update: function(){
    if (!this._mat) return;
    this._mat.metalness = this.data.metalness;
    this._mat.roughness = this.data.roughness;
    this._mat.envMapIntensity = this.data.envIntensity;
    this._mat.clearcoat = this.data.clearcoat;
    this._mat.clearcoatRoughness = this.data.clearcoatRoughness;
    this._mat.transparent = (this.data.opacity < 0.999);
    this._mat.opacity = this.data.opacity;
    this._mat.depthWrite = (this.data.opacity >= 0.999);
    if (this._mat.normalScale) this._mat.normalScale.set(this.data.normalStrength, this.data.normalStrength);
    if (this._mat.clearcoatNormalScale) this._mat.clearcoatNormalScale.set(this.data.normalStrength * 0.65, this.data.normalStrength * 0.65);
    if (this._nm1) this._nm1.repeat.set(this.data.normalRepeatX, this.data.normalRepeatY);
    if (this._nm2) this._nm2.repeat.set(this.data.normalRepeatX * 1.35, this.data.normalRepeatY * 0.85);
    if (this._mat.emissiveIntensity !== undefined) this._mat.emissiveIntensity = this.data.emissiveIntensity;
    this._mat.needsUpdate = true;
  },


  tick: function(time){
    if ((!this._nm1 && !this._nm2) || !this._mat) return;
    const S = window.__S4_MERCURY_SHARED;
    if (!S) return;

    // Flow already has "creep → freeze → creep" baked in.
    const f = S.flow || 0;
    const t = (time || 0) / 1000;

    // Stronger, readable motion: we animate UV transforms (cheap on GPU)
    const base = f * this.data.flowScale;

    const mod1 = (x) => {
      x = x % 1;
      return (x < 0) ? (x + 1) : x;
    };

    if (this._nm1){
      this._nm1.offset.x = mod1(base * 1.00);
      this._nm1.offset.y = mod1(base * 0.42 + 0.16 * Math.sin(f * 0.55 + t * 0.12) + 0.08 * Math.sin(f * 0.21));
      this._nm1.rotation = this.data.flowRotate * Math.sin(f * 0.18 + t * 0.08);
    }
    if (this._nm2){
      const wob = this.data.flowWobble * Math.sin(t * 0.27 + f * 0.33);
      this._nm2.offset.x = mod1(base * 0.72 + wob * 0.06);
      this._nm2.offset.y = mod1(base * 0.58 - wob * 0.05 + 0.10 * Math.sin(f * 0.31 + t * 0.09));
      this._nm2.rotation = -this.data.flowRotate * 0.82 * Math.sin(f * 0.14 + t * 0.06);
    }
  },

  remove: function(){
    try { if (this._mat) this._mat.dispose(); } catch(e){}
  }
});


AFRAME.registerComponent('pbr-carpet', {
  schema: {
    repeatX: {type: 'number', default: 3.0},
    repeatY: {type: 'number', default: 3.0},
    anisotropy: {type: 'int', default: 8}
  },
  init: function () {
    this.apply = this.apply.bind(this);
    this.el.addEventListener('model-loaded', this.apply);
    this.el.addEventListener('materialtextureloaded', this.apply);
    this.el.addEventListener('object3dset', this.apply);
    // Also try shortly after load in case textures arrive later.
    setTimeout(this.apply, 250);
    setTimeout(this.apply, 1200);
  },
  update: function () { this.apply(); },
  apply: function () {
    const mesh = this.el.getObject3D('mesh');
    if (!mesh) return;
    const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
    mats.forEach((mat) => {
      if (!mat) return;
      const rx = this.data.repeatX, ry = this.data.repeatY;
      const aniso = this.data.anisotropy;
      ['map', 'normalMap', 'roughnessMap', 'aoMap'].forEach((k) => {
        const t = mat[k];
        if (!t) return;
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
        t.repeat.set(rx, ry);
        t.anisotropy = aniso;
        t.needsUpdate = true;
      });
      mat.needsUpdate = true;
    });
  }
});






    </script>
<script>AFRAME.registerComponent('sharp-alpha', {
  init: function () {
    const el = this.el;
    const apply = () => {
      const mesh = el.getObject3D('mesh');
      if (!mesh) return;
      const renderer = el.sceneEl && el.sceneEl.renderer;
      const maxAniso = renderer ? renderer.capabilities.getMaxAnisotropy() : 1;

      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      materials.forEach((mat) => {
        if (!mat) return;
        // Core: stop pixel-y alpha threshold + ensure proper depth behavior
        mat.transparent = true;
        mat.alphaTest = 0.0;
        mat.depthTest = true;
        mat.depthWrite = true;
        if (window.THREE) mat.side = THREE.FrontSide;

        const map = mat.map;
        if (map) {
          map.anisotropy = maxAniso;
          if (window.THREE) {
            map.minFilter = THREE.LinearMipmapLinearFilter;
            map.magFilter = THREE.LinearFilter;
          }
          map.needsUpdate = true;
        }
        mat.needsUpdate = true;
      });
    };

    el.addEventListener('materialtextureloaded', apply);
    el.addEventListener('loaded', () => setTimeout(apply, 0));
    if (el.sceneEl) el.sceneEl.addEventListener('loaded', () => setTimeout(apply, 0));
  }
});</script><!-- -------------------------------------------------------------------------
     Photography Corridor (left wall, x≈0) — framed photos (3:2)
     NOTE: Added without touching WASD controls or spawn/camera rig.
---------------------------------------------------------------------------- -->
<!-- Photo 01 -->
<a-entity id="corridor_photo_01" position="0.01 1.8 20.5" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto01; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto01Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 02 -->
<a-entity id="corridor_photo_02" position="0.01 1.8 21.6" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto02; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto02Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 04 -->
<a-entity id="corridor_photo_04" position="0.01 1.8 23.6" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto04; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto04Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 05 -->
<a-entity id="corridor_photo_05" position="0.01 1.8 25.6" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto05; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto05Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 06 -->
<a-entity id="corridor_photo_06" position="0.01 1.8 26.7" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto06; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto06Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 07 -->
<a-entity id="corridor_photo_07" position="0.01 1.8 27.8" rotation="0 90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto07; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto07Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 08 -->
<a-entity id="corridor_photo_08" position="4.9 1.8 23.45" rotation="0 -90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto08; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto08Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 09 -->
<a-entity id="corridor_photo_09" position="4.9 1.8 25.45" rotation="0 -90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto09; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto09Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 10 -->
<a-entity id="corridor_photo_10" position="4.9 1.8 26.55" rotation="0 -90 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto10; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto10Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<!-- Photo 11 -->
<a-entity id="corridor_photo_11" position="2 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto11; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto11Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 12 -->
<a-entity id="corridor_photo_12" position="3.1 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto12; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto13Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<!-- Photo 13 -->
<a-entity id="corridor_photo_13" position="5.1 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto13; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto14Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<!-- Photo 14 -->
<a-entity id="corridor_photo_14" position="7.1 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto14; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto15Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<!-- Photo 15 -->
<a-entity id="corridor_photo_15" position="8.2 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto15; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto16Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<!-- Photo 16 -->
<a-entity id="corridor_photo_16" position="10.2 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto16; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto17Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<!-- Photo 17 -->
<a-entity id="corridor_photo_17" position="11.3 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto17; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto18Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>


<a-entity id="corridor_photo_18" position="12.4 1.8 29.9" rotation="0 180 0">
  <!-- White frame -->
  <a-plane width="1.04" height="0.706667"
           material="shader: standard; color: #ffffff; roughness: 0.95; metalness: 0.0; side: double;
                     polygonOffset: true; polygonOffsetFactor: -1; polygonOffsetUnits: -1">
  </a-plane>

  <!-- Photo (3:2, 1.0m wide) -->
  <a-plane width="1.0" height="0.666667" position="0 0 0.01"
           material="shader: flat; src: #corridorPhoto18; side: double;
                     polygonOffset: true; polygonOffsetFactor: -2; polygonOffsetUnits: -2">
  </a-plane>
  <!-- Label -->
  <a-plane width="0.65" height="0.18" position="0 -0.52 0.02"
           material="shader: flat; src: #corridorPhoto12Label; transparent: true; side: double; alphaTest: 0.5;
                     polygonOffset: true; polygonOffsetFactor: -3; polygonOffsetUnits: -3">
  </a-plane>

</a-entity>

<a-plane id="photo_label"
         width="1.14" height="2.40"
         position="2.99 1.25 19.5"
         rotation="0 -90 0"
         material="shader: flat; src: #photo_label_tex; transparent: true; opacity: 1; side: double; depthWrite: false; depthTest: true; polygonOffset: true; polygonOffsetFactor: -4; polygonOffsetUnits: -4">
</a-plane>
</a-scene>
<script>
(function(){
  const hint = document.getElementById('hint');
  function showHint(msg){
    if(!hint) return;
    hint.style.display = 'block';
    hint.innerHTML = msg;
  }
  function hideHint(){ if(hint) hint.style.display = 'none'; }

  // Try to start media as soon as possible (may be blocked by autoplay policies).
  window.addEventListener('DOMContentLoaded', () => {
    const v = document.querySelector('#fearVideo');
    const a = null; // legacy (no longer used)
    const m = document.querySelector('#fearRoomMusic');

    async function tryStart(){
      let blocked = false;

      if (v){
        v.muted = true;
        v.volume = 0.0;
        try { await v.play(); } catch(e){ blocked = true; }
      }
      if (m){
        m.muted = false;
        m.volume = 0.12;
        try { await m.play(); } catch(e){ blocked = true; }
      }

      if (blocked){
        showHint('<b>Audio blocked by browser (click to enable)</b> • click once anywhere to enable sound');
        const unlock = async () => {
          // Resume WebAudio (needed for positional video sound).
          try { if (window.THREE && THREE.AudioContext && THREE.AudioContext.getContext) { const c = THREE.AudioContext.getContext(); if (c && c.state === 'suspended') await c.resume(); } } catch(e){}
          try {
            if (v){ v.muted = false; v.volume = 1.0; await v.play().catch(()=>{}); }
          } catch(e){}
          try {
            if (a){ a.muted = false; await a.play(); }
          } catch(e){}
          try {
            if (m){ m.muted = false; m.volume = 0.12; await m.play(); }
          } catch(e){}
          hideHint();
        };
        window.addEventListener('pointerdown', unlock, { once: true });
        window.addEventListener('keydown', unlock, { once: true });
      } else {
        hideHint();
      }
    }

    tryStart();
  });
})();
</script>


<script>
  // Convert near-black pixels in an image texture to transparent alpha (so labels "print" directly on the wall).
  AFRAME.registerComponent('black-to-alpha', {
    schema: {
      threshold: {type: 'number', default: 20}  // 0-255
    },
    init: function () {
      this._applied = false;
      this._tryApply = this._tryApply.bind(this);
      this.el.addEventListener('materialtextureloaded', this._tryApply);
      this.el.addEventListener('object3dset', this._tryApply);
    },
    tick: function () {
      if (!this._applied) this._tryApply();
    },
    _tryApply: function () {
      if (this._applied) return;

      const mesh = this.el.getObject3D('mesh');
      if (!mesh) return;

      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      for (const mat of materials) {
        if (!mat || !mat.map || !mat.map.image) continue;

        const img = mat.map.image;
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;
        if (!w || !h) continue;

        // Draw to canvas and punch out near-black pixels.
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        try {
          ctx.drawImage(img, 0, 0, w, h);
        } catch (e) {
          // If the image is not CORS-readable, we can't process it.
          // (We use a CDN URL that should be readable.)
          return;
        }

        const imageData = ctx.getImageData(0, 0, w, h);
        const data = imageData.data;
        const t = this.data.threshold;

        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i+1], b = data[i+2];
          // If pixel is "near black", make it transparent.
          if (r <= t && g <= t && b <= t) {
            data[i+3] = 0;
          } else {
            data[i+3] = 255;
          }
        }

        ctx.putImageData(imageData, 0, 0);

        const tex = new THREE.CanvasTexture(canvas);
        tex.flipY = false;
        tex.needsUpdate = true;
        // Flip vertically (mirror Y) so the label text reads correctly on the wall.
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1, -1);
        tex.offset.set(0, 1);

        mat.map = tex;
        mat.transparent = true;
        mat.alphaTest = 0.01;
        mat.needsUpdate = true;

        this._applied = true;
        return;
      }
    }
  });
</script>



<!-- ===== INSERTED: Elevator Toggle Component ===== -->
<script>
  // Elevator door controller: toggles open/close and forwards events to the two door leaves.
  AFRAME.registerComponent('elevator-toggle', {
    init: function () {
      this.isOpen = false;
      this.doorL = this.el.querySelector('#elevator1_door_L');
      this.doorR = this.el.querySelector('#elevator1_door_R');

      this.el.addEventListener('elevator1-toggle', () => {
        this.isOpen = !this.isOpen;
        const evt = this.isOpen ? 'elevator1-open' : 'elevator1-close';
        if (this.doorL) this.doorL.emit(evt);
        if (this.doorR) this.doorR.emit(evt);
      });
    }
  });
</script>
<!-- ===== END INSERTED: Elevator Toggle Component ===== -->

<!-- ===== INSERTED: Elevator User Guide Overlay Logic ===== -->
<script>
  // Shows a 2D "user guide" overlay when the player is close to the elevator.
  // Purely UI; does not affect the 3D scene.
  AFRAME.registerComponent('elevator-user-guide', {
    schema: {
      target: { type: 'selector' },
      showDistance: { type: 'number', default: 6 }
    },

    init: function () {
      this.ui = document.getElementById('elevatorGuide');
      this._shown = false;
      this._p = new THREE.Vector3();
      this._t = new THREE.Vector3();
      if (this.ui) this.ui.classList.remove('show');
    },

    tick: function () {
      if (!this.ui || !this.data.target) return;

      this.el.object3D.getWorldPosition(this._p);
      this.data.target.object3D.getWorldPosition(this._t);

      const d = this._p.distanceTo(this._t);
      const shouldShow = d <= this.data.showDistance;

      if (shouldShow !== this._shown) {
        this._shown = shouldShow;
        this.ui.classList.toggle('show', shouldShow);
      }
    }
  });
</script>
<!-- ===== END INSERTED: Elevator User Guide Overlay Logic ===== -->


<script>
(function(){
  const overlay = document.querySelector('.overlay');
  if (!overlay) return;

  function fadeOut(){
    overlay.style.transition = 'opacity 600ms ease';
    overlay.style.opacity = '0';
    setTimeout(()=>{ overlay.style.display='none'; }, 650);
  }

  const scene = document.querySelector('a-scene');
  if (scene && scene.hasLoaded) { fadeOut(); return; }
  if (scene) scene.addEventListener('loaded', fadeOut, {once:true});
})();
</script>

</body>
</html>
