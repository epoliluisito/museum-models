<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>fear</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; }
    #hint {
      position: fixed; left: 12px; bottom: 12px; z-index: 10;
      font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.85); background: rgba(0,0,0,0.45);
      padding: 8px 10px; border-radius: 10px; user-select: none;
    }
    #hint b { color: #fff; }
  </style>
</head>
<body>
  <div id="hint"><b>Click once</b> to enable audio • <b>WASD / Arrows</b> move • <b>Mouse</b> look</div>

  <a-scene
    renderer="antialias: true; colorManagement: true; precision: highp;"
    background="color: #000000"
    vr-mode-ui="enabled: false"
  >
    <a-assets>
      <video
        id="fearVideo"
        src="video/test-video.mp4"
        crossorigin="anonymous"
        preload="auto"
        loop
        muted
        autoplay
        playsinline
        webkit-playsinline
      ></video>
    </a-assets>

    <!-- Lighting -->
    <a-entity light="type: ambient; intensity: 0.65; color: #ffffff"></a-entity>
    <a-entity light="type: directional; intensity: 0.85; color: #ffffff" position="6 10 8"></a-entity>
    <a-entity light="type: directional; intensity: 0.55; color: #ffffff" position="-8 9 -10"></a-entity>

    <!-- Floors & ceilings -->
    <a-plane position="9 0 15" rotation="-90 0 0" width="18" height="30"
      material="color: #060606; roughness: 1; metalness: 0"></a-plane>
    <a-plane position="9 6 15" rotation="90 0 0" width="18" height="30"
      material="color: #111111; roughness: 1; metalness: 0; side: double"></a-plane>

    <a-plane position="9 0 -4" rotation="-90 0 0" width="3" height="8"
      material="color: #060606; roughness: 1; metalness: 0"></a-plane>
    <a-plane position="9 2.2 -4" rotation="90 0 0" width="3" height="8"
      material="color: #111111; roughness: 1; metalness: 0; side: double"></a-plane>

    <a-plane position="21 0 27" rotation="-90 0 0" width="6" height="6"
      material="color: #060606; roughness: 1; metalness: 0"></a-plane>

    <!-- West wall -->
    <a-box class="collider"
      position="-0.06 2 15"
      width="0.12" height="4" depth="30"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- projection_screen_station_1 (6m wide) -->
    <a-box
      id="projection_screen_station_1"
      class="architectural-object"
      position="-0.059 2.25 10.0"
      rotation="0 90 0"
      width="6.0" height="3.5" depth="0.02"
      material="shader: standard; color: #0B0B0B; roughness: 0.9; metalness: 0.0; emissive: #000000; emissiveIntensity: 0.0"
      screen-material-switch="video: #fearVideo; inactiveColor: #0B0B0B; activeColor: #D9D9D9"
      video-canvas-texture="video: #fearVideo; canvasWidth: 3072; canvasHeight: 1192; blurPx: 0.9; persistence: 0.18; lumaCap: 0.85; grain: 0.018"
      screen-always-video="video: #fearVideo; spillLight: #projectionSpill1"
      video-positional-audio="video: #fearVideo; volume: 0.22; refDistance: 1.8; maxDistance: 18; rolloff: 1.2"
    >
      <a-entity
        id="projectionSpill1"
        position="0.20 0 0"
        light="type: spot; color: #ffffff; intensity: 0.10; angle: 48; penumbra: 0.85; distance: 7.5; decay: 2; castShadow: false"
      ></a-entity>
    </a-box>

    <!-- Other main chamber walls -->
    <a-box class="collider"
      position="9 2 30.06"
      width="18" height="4" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <a-box class="collider"
      position="4 2 -0.06"
      width="8" height="4" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="14 2 -0.06"
      width="8" height="4" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <a-box class="collider"
      position="18.06 2 12"
      width="0.12" height="4" depth="24"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- Corridor -->
    <a-box class="collider"
      position="7.44 1.1 -4"
      width="0.12" height="2.2" depth="8"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="10.56 1.1 -4"
      width="0.12" height="2.2" depth="8"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="9 1.1 -8.06"
      width="3" height="2.2" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- Station 3 block -->
    <a-box class="collider"
      position="15.75 1.5 6.06"
      width="4.5" height="3" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="15.75 1.5 15.94"
      width="4.5" height="3" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="17.94 1.5 11"
      width="0.12" height="3" depth="10"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- Final Void -->
    <a-box class="collider"
      position="5.06 1.6 25"
      width="0.12" height="3.2" depth="6"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="12.94 1.6 23.85"
      width="0.12" height="3.2" depth="3.7"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="12.94 1.6 27.65"
      width="0.12" height="3.2" depth="0.7"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="9 1.6 27.94"
      width="8" height="3.2" depth="0.12"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="8.34 1.6 21.5"
      width="0.12" height="3.2" depth="1.0"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>
    <a-box class="collider"
      position="9.66 1.6 21.5"
      width="0.12" height="3.2" depth="1.0"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- Station 4 -->
    <a-box class="collider"
      position="7 2 19.5"
      width="8" height="4" depth="3"
      material="color: #0B0B0B; roughness: 1; metalness: 0"></a-box>

    <!-- Player rig (in front of screen) -->
    <a-entity id="rig" position="1.2 0 10.0" rig-walk="speed: 2.6; radius: 0.28">
      <a-entity
        id="playerCam"
        position="0 1.6 0"
        rotation="0 90 0"
        camera="fov: 60; near: 0.05; far: 1000"
        look-controls="pointerLockEnabled: true"
        pitch-clamp="min: -80; max: 80"
      >
        <a-entity cursor="rayOrigin: mouse"></a-entity>
      </a-entity>
    </a-entity>

    <script>
      (function () {
        const DEG2RAD = Math.PI / 180;
        const EPS = 0.001;

        // Switch material color to allow video map to be visible (A-Frame multiplies map by color).
        AFRAME.registerComponent('screen-material-switch', {
          schema: {
            video: { type: 'selector' },
            inactiveColor: { type: 'color', default: '#0B0B0B' },
            activeColor: { type: 'color', default: '#D9D9D9' }
          },
          init: function () {
            this._active = false;
            this._apply(false);
          },
          _apply: function (on) {
            this.el.setAttribute('material', 'color', on ? this.data.activeColor : this.data.inactiveColor);
            this._active = on;
          },
          tick: function () {
            const v = this.data.video;
            if (!v) return;
            const hasFrame = (v.readyState >= 2) && (v.currentTime > 0 || !isNaN(v.duration));
            if (hasFrame && !this._active) this._apply(true);
            if (!hasFrame && this._active) this._apply(false);
          }
        });

        AFRAME.registerComponent('screen-always-video', {
          schema: { video: { type: 'selector' }, spillLight: { type: 'selector' } },
          init: function () {
            this._videoEl = this.data.video || null;
            this._setSpill(true);
            this._startVideo();
            window.addEventListener('pointerdown', () => this._startVideo(), { once: true });
            window.addEventListener('keydown', () => this._startVideo(), { once: true });
          },
          _setSpill: function (on) {
            const spill = this.data.spillLight;
            if (!spill) return;
            const light = spill.getAttribute('light');
            if (!light) return;
            spill.setAttribute('light', Object.assign({}, light, { intensity: on ? light.intensity : 0 }));
          },
          _startVideo: function () {
            if (!this._videoEl) return;
            try {
              this._videoEl.loop = true;
              this._videoEl.playsInline = true;
              this._videoEl.muted = true; // keep muted until WebAudio unlock
              const p = this._videoEl.play();
              if (p && p.catch) p.catch(() => {});
            } catch (e) {}
          }
        });

        // Video -> canvas texture (upscale + projection-like stability)
        AFRAME.registerComponent('video-canvas-texture', {
          schema: {
            video: { type: 'selector' },
            canvasWidth: { type: 'int', default: 2048 },
            canvasHeight: { type: 'int', default: 1024 },
            blurPx: { type: 'number', default: 0.8 },
            persistence: { type: 'number', default: 0.15 },
            lumaCap: { type: 'number', default: 0.85 },
            grain: { type: 'number', default: 0.015 }
          },
          init: function () {
            this.v = this.data.video;
            this.canvas = document.createElement('canvas');
            this.canvas.width = Math.max(256, this.data.canvasWidth|0);
            this.canvas.height = Math.max(256, this.data.canvasHeight|0);
            this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true });
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';

            this.tex = new THREE.CanvasTexture(this.canvas);
            this.tex.minFilter = THREE.LinearFilter;
            this.tex.magFilter = THREE.LinearFilter;
            this.tex.generateMipmaps = false;
            this.tex.wrapS = THREE.ClampToEdgeWrapping;
            this.tex.wrapT = THREE.ClampToEdgeWrapping;

            const applyToMesh = () => {
              const mesh = this.el.getObject3D('mesh');
              if (!mesh || !mesh.material) return;
              mesh.material.map = this.tex;
              mesh.material.needsUpdate = true;
              mesh.material.toneMapped = false;
            };
            if (this.el.getObject3D('mesh')) applyToMesh();
            else this.el.addEventListener('object3dset', applyToMesh);

            this.ctx.fillStyle = '#0B0B0B';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.tex.needsUpdate = true;
          },
          tick: function (t, dt) {
            if (!this.v || this.v.readyState < 2) return;
            const w = this.canvas.width, h = this.canvas.height;

            const p = Math.max(0, Math.min(0.45, this.data.persistence));
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.globalAlpha = p;
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, w, h);
            this.ctx.restore();

            const blurPx = Math.max(0, Math.min(3.0, this.data.blurPx));
            this.ctx.save();
            this.ctx.filter = blurPx > 0 ? `blur(${blurPx}px)` : 'none';
            this.ctx.globalAlpha = 1.0 - p;
            this.ctx.drawImage(this.v, 0, 0, w, h);
            this.ctx.restore();

            const cap = Math.max(0, Math.min(1, this.data.lumaCap));
            if (cap < 0.999) {
              const c = Math.round(cap * 255);
              this.ctx.save();
              this.ctx.globalCompositeOperation = 'multiply';
              this.ctx.fillStyle = `rgb(${c},${c},${c})`;
              this.ctx.fillRect(0, 0, w, h);
              this.ctx.restore();
            }

            const g = Math.max(0, Math.min(0.05, this.data.grain));
            if (g > 0) {
              const img = this.ctx.getImageData(0, 0, w, h);
              const d = img.data;
              const stride = 10;
              const amp = Math.floor(g * 255);
              let seed = (t|0) % 2147483647;
              const rand = () => (seed = (seed * 48271) % 2147483647) / 2147483647;
              for (let y = 0; y < h; y += stride) {
                for (let x = 0; x < w; x += stride) {
                  const i = (y * w + x) * 4;
                  const n = ((rand() - 0.5) * amp) | 0;
                  d[i] = Math.max(0, Math.min(255, d[i] + n));
                  d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
                  d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
                }
              }
              this.ctx.putImageData(img, 0, 0);
            }

            this.tex.needsUpdate = true;
          }
        });

        // Positional audio via WebAudio
        AFRAME.registerComponent('video-positional-audio', {
          schema: {
            video: { type: 'selector' },
            volume: { type: 'number', default: 0.20 },
            refDistance: { type: 'number', default: 1.8 },
            maxDistance: { type: 'number', default: 18.0 },
            rolloff: { type: 'number', default: 1.2 }
          },
          init: function () {
            this._video = this.data.video;
            this._ctx = null;
            this._panner = null;
            this._gain = null;
            this._src = null;
            this._ready = false;
            this._tmp = new THREE.Vector3();

            this._unlock = () => {
              if (this._ready || !this._video) return;
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              if (!AudioCtx) return;

              try {
                this._ctx = new AudioCtx();

                this._panner = this._ctx.createPanner();
                this._panner.panningModel = 'HRTF';
                this._panner.distanceModel = 'inverse';
                this._panner.refDistance = this.data.refDistance;
                this._panner.maxDistance = this.data.maxDistance;
                this._panner.rolloffFactor = this.data.rolloff;

                this._gain = this._ctx.createGain();
                this._gain.gain.value = this.data.volume;

                this._src = this._ctx.createMediaElementSource(this._video);
                this._src.connect(this._panner);
                this._panner.connect(this._gain);
                this._gain.connect(this._ctx.destination);

                this._video.muted = false;
                this._video.volume = 0.0;

                const p = this._video.play();
                if (p && p.catch) p.catch(() => {});
                if (this._ctx.state === 'suspended') this._ctx.resume().catch(() => {});
                this._ready = true;
              } catch (e) {
                this._ready = false;
              }
            };

            window.addEventListener('pointerdown', this._unlock, { once: true });
            window.addEventListener('keydown', this._unlock, { once: true });
            document.addEventListener('pointerlockchange', () => { if (document.pointerLockElement) this._unlock(); });
          },
          tick: function () {
            if (!this._ready || !this._panner) return;
            const p = this.el.object3D.getWorldPosition(this._tmp);
            if (this._panner.positionX) {
              this._panner.positionX.value = p.x;
              this._panner.positionY.value = p.y;
              this._panner.positionZ.value = p.z;
            } else {
              this._panner.setPosition(p.x, p.y, p.z);
            }
          }
        });

        // Clamp look pitch
        AFRAME.registerComponent('pitch-clamp', {
          schema: { min: { type: 'number', default: -80 }, max: { type: 'number', default: 80 } },
          tick: function () {
            const lc = this.el.components['look-controls'];
            if (!lc || !lc.pitchObject) return;
            const minR = this.data.min * DEG2RAD;
            const maxR = this.data.max * DEG2RAD;
            lc.pitchObject.rotation.x = Math.min(maxR, Math.max(minR, lc.pitchObject.rotation.x));
          }
        });

        // Custom rig movement + collisions
        AFRAME.registerComponent('rig-walk', {
          schema: { speed: { type: 'number', default: 2.6 }, radius: { type: 'number', default: 0.28 } },
          init: function () {
            this.keys = Object.create(null);
            this._colliders = [];
            this._tmpVec3 = new THREE.Vector3();
            this._lastColliderRefresh = 0;

            const MOVE_KEYS = new Set(['KeyW','KeyA','KeyS','KeyD','ArrowUp','ArrowLeft','ArrowDown','ArrowRight']);
            this._onKeyDown = (e) => { if (MOVE_KEYS.has(e.code)) e.preventDefault(); this.keys[e.code] = true; };
            this._onKeyUp   = (e) => { if (MOVE_KEYS.has(e.code)) e.preventDefault(); this.keys[e.code] = false; };
            this._clearKeys = () => { for (const k in this.keys) this.keys[k] = false; };

            window.addEventListener('keydown', this._onKeyDown, { passive: false });
            window.addEventListener('keyup', this._onKeyUp, { passive: false });
            window.addEventListener('blur', this._clearKeys);
            document.addEventListener('visibilitychange', () => { if (document.hidden) this._clearKeys(); });
            document.addEventListener('pointerlockchange', () => { if (!document.pointerLockElement) this._clearKeys(); });

            const scene = this.el.sceneEl;
            if (scene.hasLoaded) this._refreshColliders();
            else scene.addEventListener('loaded', () => this._refreshColliders());
          },
          _refreshColliders: function () { this._colliders = Array.from(this.el.sceneEl.querySelectorAll('.collider')); },
          _getYaw: function () {
            const cam = document.getElementById('playerCam');
            const lc = cam && cam.components && cam.components['look-controls'];
            if (lc && lc.yawObject) return lc.yawObject.rotation.y;
            return cam ? cam.object3D.rotation.y : 0;
          },
          _aabbExpanded: function (el, radius) {
            const pos = el.object3D.getWorldPosition(this._tmpVec3);
            const w = parseFloat(el.getAttribute('width'))  || 1;
            const d = parseFloat(el.getAttribute('depth'))  || 1;
            return { minX: pos.x - w/2 - radius, maxX: pos.x + w/2 + radius, minZ: pos.z - d/2 - radius, maxZ: pos.z + d/2 + radius };
          },
          _resolveX: function (x, z, dx, radius) {
            let nx = x + dx;
            for (let i = 0; i < this._colliders.length; i++) {
              const a = this._aabbExpanded(this._colliders[i], radius);
              if (nx > a.minX && nx < a.maxX && z > a.minZ && z < a.maxZ) nx = (dx > 0) ? (a.minX - EPS) : (a.maxX + EPS);
            }
            return nx;
          },
          _resolveZ: function (x, z, dz, radius) {
            let nz = z + dz;
            for (let i = 0; i < this._colliders.length; i++) {
              const a = this._aabbExpanded(this._colliders[i], radius);
              if (x > a.minX && x < a.maxX && nz > a.minZ && nz < a.maxZ) nz = (dz > 0) ? (a.minZ - EPS) : (a.maxZ + EPS);
            }
            return nz;
          },
          tick: function (t, dt) {
            if (t - this._lastColliderRefresh > 1500) { this._refreshColliders(); this._lastColliderRefresh = t; }

            const dtS = Math.min(0.05, dt / 1000);
            const speed = this.data.speed;
            const r = this.data.radius;

            const w = !!this.keys['KeyW'] || !!this.keys['ArrowUp'];
            const s = !!this.keys['KeyS'] || !!this.keys['ArrowDown'];
            const a = !!this.keys['KeyA'] || !!this.keys['ArrowLeft'];
            const d = !!this.keys['KeyD'] || !!this.keys['ArrowRight'];

            let f = (w ? 1 : 0) - (s ? 1 : 0);
            let str = (d ? 1 : 0) - (a ? 1 : 0);
            if (f === 0 && str === 0) return;

            const mag = Math.hypot(str, f);
            if (mag > 1e-6) { str /= mag; f /= mag; }

            const yaw = this._getYaw();
            const sin = Math.sin(yaw), cos = Math.cos(yaw);

            const forwardX = -sin, forwardZ = -cos;
            const rightX = cos, rightZ = -sin;

            const moveX = (rightX * str + forwardX * f) * speed * dtS;
            const moveZ = (rightZ * str + forwardZ * f) * speed * dtS;

            const pos = this.el.object3D.position;
            const nx = this._resolveX(pos.x, pos.z, moveX, r);
            const nz = this._resolveZ(nx, pos.z, moveZ, r);
            pos.x = nx;
            pos.z = nz;
          }
        });
      })();
    </script>
  </a-scene>
</body>
</html>
